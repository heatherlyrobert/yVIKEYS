.TH vi-keys 7 2010-Jan "linux" "heatherly custom tools manual"
.na

.SH NAME
yVIKEYS \- interactive system usage and navigation

.SH DESCRIPTION (short)
yVIKEYS is a standardized, fullsome, vi/vim-like, purely keyboard-centric,
modal interface and application framework to provide wicked, powerful, and
high-end features to ALL my applications.

.SH MODES

.B definition (D).  
every system uses modes -- editing, reviewing, searching, publishing.  a mode
is simply a work context with its own specific and unique views, keys, menus,
actions, and commands.

.B complication (C).  
each application has its own modes and actions.  every simplifies for
novice users, making dumb things easy and hard things nearly impossible.
capabilities atrophy or never exist.

.B answer (A).  
standardize modes and capabilities, then build a universal, keyboard-centric
vim-like modal interface, focused on technical, power users who can stomach
a one-time, steep learning curve.

.B mode types
   -- main        broad abilities, free-flow interaction, long usage
   -- sub-mode    more specific focus, linear interaction, short usage
   -- micro-mode  tight focus, short key sequences, exit automatically

.B six main modes (MODE)
   G   god         special 3d-style omnicient pov and review
   P   progress    manage 4d timelines and action over time
   M   map         special 2d-style when content is partitioned
   S   source      normal review of content (vi/vim normal mode)
   :   command     provides a host of complex capabilities
   /   search      find and manipulate data and objects

.B sub-modes (SMOD)
   V   visual      map/object based visual selection
   \\   menu        menu system
   f   format      data presentation formatting
   o   object      object presentation formatting
   w   wander      allow pointing at object to ID them
   s   select      source/character based visual select mode
   r   replace     overwrite characters in source mode
   e   error       display and act on errors or troubles
   I   input       adding new or updating existing content
   O   omni        special 3d-style omnipotent manipulation

.B micro modes (UMOD)
   9   repeat      replay commands multiple times
   "   register    object registers to move/transfer objects
   '   mark        identify locations for return
   @   macro       keyboard macro recording and execution
   h   hint        provide automatic and manual labeling
   c   char_find   linewise searching for particular characters
   ,   buffer      select a buffer/tab/document to focus
   t   text_reg    text registers to move/transfer text
   f   units       change number auto-scaling


provide focused capability, more limited options, specific key sequences,
and often exit automatically when done.

.B note
   vim combines map/source as it is really a collection of lines

.SH MAJOR FUCKING DIFFERENCES
.b summary...
   -- 'd' and 'c' multikey combinations are gone

vi/vim is amazing and its hard to justify any changes to such a tried and true
system.  its worked well for generations of programmers.  how could anyone
know better or improve it without "full" knowledge.  and, then, once you have
full ability, why change it.  hahahahaha.

first, multi-key sequences can be dangerous.  they were developed to keep
screen refresh traffic down.  awesome, but this is not the most important
thing anymore.  it is hard to visualize the impact of complex 'd' or 'c'
keys, so i think it would be better to insist these complex keys go through
selection first.  it adds a key ('v'), but then you can properly see the
anticipated change.





.SH SECTIONS
   -- modal interface and modes
   -- x/horizontal movement
   -- y/vertical movement
   -- z/zoom movmement
   -- time/versioning/branching/undo/redo/play control
   -- editing/input/replace
   -- search, regex, and replace
   -- location marks
   -- hints and marking
   -- selection
   -- grouping/folding
   -- cut/paste buffers
   -- macros/scripts/repeating
   -- windows/buffers
   -- file/save/open

.SH SPECIAL CHARACTERS
.B situation (S).  
applications depend on many types of characters -- content, delimiters,
special symbols, delayed input, and controls.

.B complication (C).  
it is normally only easily to input, edit, and show ascii 7bit safe, non-control
characters (32-127 range).

.B answer (A).  
i will standardize ascii 128-255, update my font, and add standard escaped
sequences all applications can use.

.B caveat (!)
i don't care if it works on everyone's system ;) i can choose the lowest
common denominator, or choose badass and productive.

.B adding high frequency invisible characters
   \\s     ·     visible space
   \\n     ¦     delayed return
   \\e     ¥     delayed escape
   \\b     ¿     delayed backspace
   \\d     ¾     delayed delete

.B adding file and editing control characters
   \\g     ¨     group separator for records/files
   \\f     §     field separator for records/files
   \\p     ¤     placeholder for current position during input
   \\"     ¶     delayed double quote for file/input reading
   \\\\     µ     delayed backslash for file/input reading

.B adding macro control characters
   \\'     ´     noop, just wait a single beat
   \\,     «     wait/pause for a half-second (0.5s)
   \\.     ª     breakpoint during execution, enter playback
   \\+     ©     update screen contents (in case of fast execution)
   \\q     ³     quit/halt execution entirely
   \\0     £     visible null

.B adding greek characters
   type \\ first, then one of the latin characters below
   è é ê ë   ì í î ï   ð ñ ò ó   ô õ ö ÷   ø ù ú û   ü ý þ ÿ 
   A B G D   E Z H Y   I K L M   N X O P   R S T U   F C Q W

.B adding mathmatical charcters
   type \\ first, then one of the latin characters below
   ß Ý Þ æ    Ë Ì Í    Î Æ Ç È É Ê    À Á Â Ã Ä Å    ¸ ¹ º » ¼ ½
   / < > ~    # a r    1 2 3 4 x y    5 6 7 8 9 z    ( ) [ ] { }

.B adding other useful characters
   type \\ first, then one of the latin characters below
   · ´ Ï    ¢ ¡    Ô Ó Ö Õ    Ð Ñ Ò    ® ¯    å ± ¬    ²
   s ' @    ? !    j k h l    & | ^    : %    = $ *    <sp>

   type \\_ first, then one of the latin characters below
   × Ø    ° Ù Ú Û Ü ç    à á â ã ä
   a e    t i p f c o    j k h l m

.SH MAP mode (movements)

.B horizontal movements
   basic      0HhlL$          left full, 5x, 1x; right 1x, 5x, full
   goto       g [shcle]       goto a fixed location on screen
   scroll     z [shcle]       bring current to fixed position
   pages      c [sh·le]       full and half page jumps
   ends       e [sHhCclLe]    goto the end of content
   exact      Ë|              move to specific col (x)

.B vertical movements
   basic      _KkjJ~          up full, 5x, 1x; down 1x, 5x, full
   goto       g [tkmjb]       goto a fixed location on screen
   scroll     z [tkmjb]       bring current to fixed position
   pages      c [tk·jb]       full and half page jumps
   ends       e [tKkMmjJb]    goto the end of content
   exact      Ë:              move to specific row (y)

.B zoom movements
   basic      <OoiI>          zoom
   goto       g [nopif]       goto a fixed location on screen
   scroll     z [nopif]       bring current to fixed position
   pages      c [no·if]       full and half page jumps
   ends       e [nOoPpiIf]    goto the end of content
   grid       g [0123456789]  zoom one level in (0=out) using 3x3 grid
   exact      Ë%              move to specific zoom level (z)

.B combination (horz/vert) movements
   goto       g [AaUuDdZz.]   goto a fixed corner or center
   scroll     z [audz.]       bring current to a fixed corner/center
   ends       e [audz]        goto the end of content
   pages      c [AaUuDdZz]    full and half page jumps
   exact      :<label>        go to specific location


.SH MAP mode

.SS major changes
.B no selection
   x¢         clear and move ¢ direction
   d¢  D¢     delete and fill from ¢ direction (capital is copy)
   a¢  A¢     append/insert in ¢ direction     (capital is copy)
   y Y        yank/copy or yank/clear
   p P        paste (paste special) to current selection

.B with selection
   x          clear selection
   d¢         delete selection and fill from ¢ direction
   a¢         append/insert size of selection in ¢ direction
   y Y        yank/copy or yank/clear
   r R        repace from register into current size only

.SS mode changes
   G       change to god mode
   :       change to command mode
   /       change to search mode
   ,p      change to progress window/mode

.SS sub-mode changes
   ,       change to buffer sub-mode
   \\      change to menu sub-mode
   "       change to register sub-mode
   @       change to macro sub-mode
   E       change to error sub-mode
   F       change to formatting sub-mode

.SS micro-mode changes
   v       begin visual selection
   M V     change to visual micro-mode
   ' m     change to mark micro-mode
   ;       change to hint micro-mode

.SS editing a single cell/object
   -       clear cell, begin a negative number
   +       clear cell, begin a positive number
   =       clear cell, begin a numeric formula
   #       clear cell, begin a string formula
   s       clear cell, begin a string
   ¦       change to source mode to edit existing contents

.SS undo and redo changes at map-level
   u       undo last change
   U       redo last change

.SS changes (change.txt)
clear        (x)
delete       (d)
replace      (rsc)
copy         (y)
paste        (p)
filter/sort


g~  switch case

.SS simple movements

.SS copy and move text

.B clear (remove content, leave blank)
   x + [hljkio]    clear current and move one in direction
   x + [xyzXYZ]    clear full cols, rows, or silos
   x.              clear and remain in place





.B delete (remove content and position)
   d + hljkio      delete and pull from direction to fill-in 

.SH MENU smode
.SS ---basics---------------------------------------------------------
 µ´´´      perform a single command through the menus
.SS ---overview-------------------------------------------------------
.B situation (S).  
there are two primary ways to request actions in yVIKEYS -- keystrokes within
modes and the command line.

.B complication (C).  
but, keystrokes and commands require direct memorization and can not be
browsed making them forbidding.

.B answer (A).  
i will provide a universal, standard, three-level menu system to package
commands for browsing, retrieval, and use.

.B design.  
narrow, deep, or uneven menu systems are difficult to navigate.  yVIKYES
is always three layers and very wide.
.SS ---full capabilities----------------------------------------------

.B invoking/exiting the mode
   µ          begin menu mode and show the top level
   ¥          exit early from menu selection

.B executing a menu option
   µ´´´       request a specific packaged command (no ¦)
   µ´´´····¦  request item, but requires additional input

.B top level menu organization (18)
   µf         files, import, export, and filesystem
   µe         edit, undo/redo, copy/paste
   µv         view, control various screen elements
   µi         insert, add various elements to content
   µs         select, to prepare groups of items for action
   µo         format, control presentation of items
   µm         modify, control size and shape of items
   µd         dataset, filter and control large data groups
   µt         tools, select specialty filters for use
   µp         pallete, colors, sounds, smells
   µl         layers, manage slices of content
   µb         buffers, coordinate multiple files
   µg         language, support specific content types
   µa         auditor, review content, grammer, formulas
   µx         execute, control content usage
   µc         config, control global program behavior
   µs         script, control macros and scripts
   µh         share, publish, print, transfer

.B notes
   -- i surveyed every well-done menu from 1-2-3 to macintosh
   -- very useful in macros and scripts for clarity
   -- menus are absolutely standard and universal
   -- top menu is always the same in every application

.SH COMMAND mode
.SS ---basics---------------------------------------------------------
 :´´´¦      perform a single command
.SS ---overview-------------------------------------------------------
.B situation (S).  
rapid, simple, and frequent commands belong assigned to keystrokes.  they are
used enough to be driven into muscle memory.

.B complication (C).  
but, complicated or argument driven commands are often neglected, messy,
and/or crammed into menus and dialogs.

.B answer (A).  
i will standardize on a vim-like command line with relatively standard
commands which parallel vi/vim's version.
.SS ---full capabilities----------------------------------------------

.B invoking/exiting the mode
   :          opens the command mode at the bottom of the screen
   ¦          executes the command and returns to the prev mode
   ¥          forgets the typed text/command and returns to prev mode

.B history
   ::¦        re-run the last command executed (same as ::0¦)
   ::Ë¦       re-run the last minus count Ë command
   :¿m¢¦      mark current command as ¢ [A-Za-z]
   :¿u¢¦      unmark command presently marked as ¢
   ::¢¦       re-run the command marked as ¢
   :::        display history list, move with _KkjJ~, ¦ to edit or ¥

.B files and tabs...
   :file <name>    changes the current spreadsheet name
   :write          writes the currrent spreadsheet to file (:w)
   :quit           exit the program
   :rename <name>  changes the name of the current tab
   :resize <addr>  changes the size of a tab



.SH SEARCH mode
.SS ---basics---------------------------------------------------------
/´´´¦      perform a regular expression search of diplayed text
.SS ---overview-------------------------------------------------------
.B situation (S).  
using content/attributes to identify an entry/object or related group of them
is fundamental to almost every application.

.B complication (C).  
very few applications provide any serious search capability, especially one
that can navigate and manipulate them.

.B answer (A).  
i will standardize on a vim-like search line that uses regular expressions
and standard input and source modes.
.SS ---full capabilities----------------------------------------------

.B invoking/exiting the mode
   /          begin search mode, directly to input mode
   ¦          executes immediately, returns to the prev mode
   ¥          from search (not input), forgets search, exits

.B mode structure
   source     search acts exactly like source mode (all keys, regs)
   input      edit keys (IiAaRr) change to input, ¥ returns, ¦ runs
   history    /// exits input to source, then brings up history

.B basics
   /¦         clear the search findings
   /´´´¦      extended regex search (heatherly variant)
   /!´´´¦     literal search, no special characters
   ¥          from input mode, back to source mode

.B map-mode keys to navigate found items
   [          first entry
   <          previous entry                          [vim is n      ]
   >          next entry                              [vim is N      ]
   ]          last entry

.B history
   //¦        re-run the last search executed (same as //0¦)
   //Ë¦       re-run the last minus count Ë search
   ///        display history list, move with _KkjJ~, ¦ to edit or ¥

.B marking [searches are marked as A-Za-z]
   /¿m¢¦      mark current search as ¢
   //¢¦       re-run the search marked as ¢
   /¿u¢¦      unmark search presently marked as ¢

.B input and editing
   input is done with standard umode, including special characters
   editing is done with standard mode, including selection, buffers



.SH KEYBOARD MACROS (sub-mode)
.SS ---basics---------------------------------------------------------
 qa...q     record live keystrokes ... into macro 'a'
 @a         execute macro 'a' from current position
.SS ---overview-------------------------------------------------------
.B definition (D).  
macros are a fast, simple, and powerful productivity mechanism to save and
repeat keystrokes as if typed in real-time.

.B value (V).  
many actions are repeated, macros save time and mistakes.  tedious editing
changes are often avoided due to the work involved.

.B situation (S).  
macros are well and long established, explored, tested, and used in
keyboard-centric applications.

.B complication (C).  
given modern focus on mouse and touch, macros and their productivity gains
are either rudimentary or non-existant.

.B answer (A).  
i want these productivity gains badly.  all my applications will have a
powerful and vim-ish keyboard macro capability.

.B extras (E).  
macros can call each other, debug using stepwise execution, keystroke grouping,
flattening, and shared macro library.
.SS ---full capabilities----------------------------------------------

.B named macros (26 common, 60 total)
   a-z        lower case (26) are common, interactive use
   A-Z (*)    alternate name for lower case, signify append/debug
   0-9        numeric (10) internal for installing complex macros
   è-ÿ        greek (24) are holders for global library macros

.B recording new macros
   qd´´´q     record live keystrokes ´´´ into macro macro 'd'
   qd´´´Q     exit recording and do not save macro
   qdq        erase macro macro 'd' (record nothing)
   qD´´´q     append more keystrokes ´´´ onto end of macro 'd'
   Q          reset macro recording and execution environment
   * automatically shows a macro recording status line to help

.B executing existing macros
   @d         execute macro 'd' at the current location
   @@         re-execute the last used macro
   5@d        execute macro 'd' five times
   @D         execute macro 'd' in playback/debug mode
   * automatically shows a macro execution status line to help

.B special repeat grouping
   (´´´)      keystrokes can be grouped/organized
   Ë(´´´)     each group can be repeated any Ë times
   (´´(´´)´)  grouping can be nested up to 20 levels

.B flattening into a single macro (and installing later)
   bring macro and sub-macros together into a single unit
   uses a mechanism like regex capture groups to flatten
   :flatten f z    flatten f and all its sub-macros into z
   ¸´´´¹           represents a sub-macro when flattened
   ¸@2¹            call to a already integrated sub-macro
   :install z      break z into 0 main and 1-9 subs

.B defining macros at command line
   :macro a¦            purge lower case macros (also 0 and è)
   :macro h=¦           clears macro h
   :macro h=´´´¦        directly input and save the macro
   :macro i="´´´"¦      allows ¦ (ret) and ¥ (esc)
   :macro i=\\n\\e¦       also allows ¦ (ret) and ¥ (esc)
   :macro j=\\"´´´¦      escaped quote can go anywhere
   :macro j="´´´¦       leading " allowed if no final "
   :macro J="´´´"¦      appends to existing macro 'j'
   all leading, internal, and trailing whitespace is meaningful

.B moving and copying macros at command line
   :macro ab¦           copies macro 'b' into macro 'a'
   :macro Ab¦           appends macro 'b' unto end of macro 'a'
   :macro a>b¦          copies macro to source register 'b'
   :macro a>¦           copies macro to unnamed source register
   :macro a<b¦          copies macro from source register 'b'
   :macro a<¦           copies macro from unnamed source register
   :macro A<b¦          appends macro from named source register
   :macro a-¦           exports macro keys to vi_clip.txt
   :macro a+¦           imports macro keys from vi_clip.txt
   :macro A+¦           appends keys from vi_clip.txt
   :dump macros¦        lists all macros in vi_clip.txt

.B central macro repository
   location   /home/shared/yVIKEYS/repository.macro
   organize   major (3-12c), minor (3-12c), title (3-12c)
   record     ´´´ § ´´´ § ´´´ § desc (<60c) § keystrokes
   index      major.minor.title (example --.--.--)
   :macro a!--.--.--¦   imports macro 'a' from central repository

.B debugging and playback controls
   0-9 + -    set the speed, increment, decrement
   n s b p d  screen updates (norm, slow, blinks, peeks, blind)
   ·          step forward one (space)
   ,          run at delay speed and screen updates
   .          stop delay and return to manual playback
   ¦          run to end at full speed (return)
   ¥          terminate at current point (escape)

.B special control characters in macros (SPECIAL CHARACTERS)
   ·          space to help visually debug macros (zero time)
   ´          wait one keystroke/beat (helps with pacing)
   ª          drop out of run into playback mode
   ³ or £     stop/halt execution in any mode
   «          wait half-second (0.5s) or smallest beat available
   ©          display update now, regardless of update settings
   º´´´´»     executes within at blitz/blind speeds (super fast)

.B execution speed control (µr is script menu option)
   µre¢       adjusts macro execution speeds
   µrd¢       adjusts macro playback (debug) speeds

.B gyges-specific editing existing macros
   location   in gyges, macros are saved on tab ¯ (system)
   editing    edit like any other cell
   saving     they automatically save with the spreadsheet
   loading    latest automatically fetched when executed

.SH HINTS (sub-mode)
.na
.SS ---basics-----------------------------------------------------------------
 ;;be        go to location labeled with two-letter mark "be"
.SS ---overview---------------------------------------------------------------
.B definition (D).  
hints are two-letter labels, assigned by the application, that act as a
quick mechanism to identify, access, or move to important locations, items,
or objects without a pointing device.

.B source/prototype (S).  
firefox extension called vimperator which appears to have copied from another
early firefox extention called "hit-a-hint".  the ability i love is called
extended hints.

.B value (V).   
rapid idenfification of locations is critical to idenfitying, navigating,
and accessing locations, items, or objects in an efficient, accurate, and
confident way.

.B complication (C).  
this is an uncommon feature.  most users have never had this ability and so
are are not versed in its use and would likely not understand the value.

.B answer (A).  
i will standardize "mostly" on the excellent vimperator extended hints
interface and make it absolutely universal.  this is a very, very powerful
feature if adapted everywhere.

.B top requirements to get it right
   -- very easy, quick, and simple interface
   -- large set of hints to navigate large data sets
   -- standard rule-sets for marks to make them universal

.SS ---full capabilities------------------------------------------------------
.B mark list (62 primary, plus previous and special)
   aa-aZ      general location hints
   Aa-LZ      compilier, checker, error, feedback hints
   Ma-ZZ      global search hints
   [ < > ]    first, prev, next, and last existing hint

.B invocation of sub-mode
   ;          identify a mark
   ¥          exits sub-mode early and forgets action

.B focusing on hints
   ;;be       focus on hint "be"
   ;¥  ;;¥    clear hint focus and show all hints again
   ;¦  ;;¦    show/hide hints

.B quick movements
   ;>         go to the next hint
   ;[         go to the first hint

.B extended hints actions (potential, future)
   ;s<cc>     save link destination
   ;f<cc>     focus and center
   ;e<cc>     focus and show exploded view
   ;z<cc>     focus, zoom, and center
   ;i<cc>     zoom in, and open
   ;o<cc>     zoom out, and close
   ;x<cc>     delete
   ;y<cc>     yank
   ;p<cc>     paste
   ;t<cc>     open in another tab
   ;w<cc>     open in another window

.B showing and debugging all hints
   ;?         show hint information window
   ;!         shows hints as the status line (:status hint)
   ;_         show/hide hints



.SH GROUPING vs LAYERING
.B grouping
allows positionally related items to be linked and delt with more simply as
a unit, e.g., fingers, palm, joints, muscles, viens, and tendons grouped into
a hand.  it is typically used to position, manipulate, and alter items together
in ways that are difficult separately, like rotating a three dimensional
model around a common axis.
       
.B layering
allows the linking dissperate elements by function, themes, authors, times,
etc, e.g., springs, creeks, canals, and rivers brought into a waterways layer.
layering is typically used to add and remove details in order to better
focus, like taking power, vegetation, and buildings off a map to see the
roads more clearly.



.SH DATASETS and LAYERS (commands)
.nf
.SS ---overview-------------------------------------------------------
.B definition (D).  
links dissperate elements by function, theme, author, etc, e.g., creeks,
canals, and rivers brought into a waterways layer.

.B value (V).  
used to add and remove details to better focus, e.g., taking vegetation
and buildings off a map to see the roads more clearly.

.B situation (S).  
layering is quite well explored, tested, and perfected in science and
engineering.  this is not new ;)

.B complication (C).  
it is quite well explored in CAD, GIS, and markup applications, but not well
represented in almost any other contexts.

.B answer (A).  
i will build basic layering selection and drawing framework into yVIKEYS to
expand my use and make it easy.
.SS ---full capabilities----------------------------------------------
.B datasets
must be added and removed from yVIKEYS by the host application, which links a
name to a drawing function for display.  once a dataset is available, any of
the following can be done.

.B layer list (60 in three groups)
   layers are drawn sequentially, ones on top obscuring those below
   0-9        topmost, highlighting and overlays
   a-z        normal layers
   è-ÿ        base, underlayment layers for context
   ÿ is the bottommost and 0 is the topmost.

.B assigning a dataset to a specific layer
   :layer test f     assigns "test" to 'f', and shifts existing down
   :layer test F     assigns "test" to 'f', and shifts existing ud
   :layer all        assigns all datasets in order they were added

.B assigning a dataset to various general locations
   :layer test _     assigns to '0' (top) and shifts existing down
   :layer test [     assigns to 'a' (head) and shifts existing down
   :layer test <     assigns one above last assignment
   :layer test +     assigns to the middle most 'm', and shifts down
   :layer test >     assigns one below last assignment
   :layer test ]     assigns to 'z' (tail) and shifts existing up
   :layer test ~     assigns to 'ÿ' (bottom) and shifts existing up

.B moving layers around
   :layer jx         moves 'j' to 'x' and moves existing down
   :layer jX         moves 'j' to 'x' and moves existing up
   :layer f_         shifts 'f' to head '0' and moves existing down
   :layer f[         shifts 'f' to head 'a' and moves existing down
   :layer m(         swap 'm' and the mark to the left
   :layer f<         shove 'f' and all to the left, left
   :layer c+         move 'c' to middlemost and move existing down
   :layer k)         swap 'k' and the mark to the right
   :layer o>         shove 'o' and all to the right, right
   :layer b]         shifts 'b' to tail 'z' and moves existing up
   :layer b~         shifts 'b' to tail 'ÿ' and moves existing up

.B make a layer current
   :layer f          make 'f' current, but no other action
   also, _[<(+)>]~ work on the current, and update it as they move

.B removing layers, not the dataset
   :layer j#         unassigns the dataset in 'j'
   :layer none       unassigns all datasets, nothing displayed

.B dislaying layer inventory
   :layers show      displays layer inventory in nav window
   :layers hide      takes away layer inventory view

.B displaying other information
   :status layers    shows summary info line in status

.B future notes (not available)
   layer display area which acceps keys, making it easier
   layer history view to see data sets and layers
   :layer compact    moves/compacts layers towards middles 5, m, and ó
   :layer save       save current settings to to a working file
   :layer load       load current settings from a working file





.SH TAGS and GROUPING (micro-mode)
.nf
.SS ---basics---------------------------------------------------------
 t´´t´´t    mark a series of locations
 gg         group current tags into a unit
.SS ---overview-------------------------------------------------------
.B definition (D).  
grouping is the joining together of related elements into a larger organization
which can then be treated as a whole.

.B value (V).  
groups allow related elements to be repeatably acted upon while avoiding
errors and time-consuming, tedious selection.

.B situation (S).  
grouping is very well established and used within certain applications,
primarily in graphics processing.

.B complication (C).  
these features are often implemented differently and selectively and therefore
are not always available.

.B answer (A).  
i want these productivity gains badly.  all my applications will have a useful
and powerful tagging and grouping capability.
.SS ---full capabilities----------------------------------------------
.B location tagging
   t          temporarily tags the current location, visually marking
   T          un-tags the current location
   gg         groups the current tags into a new group
   µ

.B tag grouping

.B tag grouping
   ;g         list and or shows current groups and idenifiers
   ???        un-groups 




.SH LOCATION MARKS (sub-mode)
.na
.SS ---basics-----------------------------------------------------------------
 ma          mark current location/object with letter 'a'
 'a          return to location/object 'a'
.SS ---overview---------------------------------------------------------------
.B definition (D).  
marks (sometimes called bookmarks) are concise, temporary references to
locations or objects which allow a user to quickly record their current
position and easily return to it later.

.B value (V).   
easily marking and returning to locations/objects is critical for efficiency,
accuracy, and confidence.  it also enables advanced editing, accurate data
movements, clever scripting.

.B complication (C).  
most users are not versed in their use, so they are underimplemented.
when built, they are typically a little cludgy, using menus or buttons; so,
the feature just attrophies over time.

.B answer (A).  
i will standardize "mostly" on the excellent vim marks interface and make
it absolutely universal.  marks are a perfect partner to hints, which i will
port from vimperator.

.B top requirements to get it right
   -- very easy, quick, and simple interface
   -- large set of marks to allow advanced actions
   -- overview, status, and highlighting to help debugging
   -- command mode interface to define and clear marks
   -- facility for interactively moving/adjusting marks
.SS ---full capabilities------------------------------------------------------
.B mark list (62 primary, plus previous and special)
   a-z        static location marks (never move)
   A-Z        moving object/content marks (move with object)          [TBD/NYI]
   0-9        script-only and programming marks (prevent collisions)  [TBD/NYI]
   '          unnamed, from where you jumped to a mark
   * ( )      visual range, top-left, bottom-right (use '* to select)       
   [ < > ]    first, prev, next, and last existing mark

.B invocation of sub-mode
   m          record a new mark in map or god mode
   '          return to an existing mark in map or god mode
   ¥          exits sub-mode early and forgets action

.B setting marks
   ma         set location of mark 'a'
   m(         set top-left corner of future visual selection
   m# '#      clear mark under cursor
   m?a        view list of all marks, then mark as 'a'

.B using marks
   'a         return to mark 'a'
   ''         return to where the last mark was called
   '[         go to first mark in [a-zA-Z]
   '?a        view list of all marks, then return to mark 'a'
   '*         enter visual mode from '( to ')

.B moving marks in wander mode
   '@         move mark under cursor
   ...        basic horizontal and vertical keys to move mark
   ¦          enter to stop editing, move mark, and exit mode

.B command line
   :mark a=0a1¦    set mark at an address
   :mark a=¦       unset a mark  (go to a ('a) and delete ('#))
   :mark clear¦    unset all lower case marks
   :mark purge¦    unset all-all marks

.B showing and debugging all marks
   m! '!      shows marks as the status line (:status mark)
   m_ '_      show/hide mark visual highlighting

.B limits/warnings
   changes to marks can not be undone (they are simple/quick)

.SH BUFFERS (AND PANELS) MICRO-MODE
.SS ---basics---------------------------------------------------------
 ,a         switch to the main editing panel
 ,3         show the fourth file in the current panel
.SS ---overview-------------------------------------------------------
.B definition (D).  
buffers are active datasets to be viewed or edited, and panels are screen
regions within which to work.

.B situation (S).  
many application support multiple buffers (or windows) as it allows complex
editing, data movemente, and flexibility.

.B complication (C).  
support and access to these features vary wildly and tend to require pointing
and drop-down menus.

.B answer (A).  
create a micro mode that manages rapid buffer changes, and marry that with
commands and menus for less frequent activities.

.SS ---full capabilities------------------------------------------------------

.B invocation
   ,          enters buffer micro-mode (from map mode)
   ¥          exits micro-mode early and forgets action
   µb         call up buffers menu
   all options are two-character sequences (except search)

.B standard identifiers
   0-9A-Z     thirty-six (36) standard buffers
   ® ¯        summary and system buffers for some applications
   a-z        standard panel/work-area identifiers

.B direct switching...
   a          switch to primary editing window/panel
   0          view the first buffer in current window/panel

.B cursoring (follow standard)...
   [  ]       very first and very last (of any kind)
   (  )       first and last (normal types 0-9A-Z)
   <  >       prev and next (of any kind)
   ,          saved from last call

.B searching by name (regex)...
   /´´´¦      first matching tab name based on regex

.B information...
   !          display buffer content in status line
   ?          display info window listing buffer details

.B standard windows/panels...
   a          main editing window
   b          buffer listing area
   g          global find and search
   p          progress bar/timeline
   q          compilation and build
   t          tag window to left

.B major menu items
   µb         buffer menu
   µb_        change status line to buffer option
   µbw·´´´¦   change the current buffer name
   µbz·´´´¦   update current buffer size
   µbg¢       goto first, prev, next, last, specific buffer
   µbd¢       update col, row, and layer defaults

.B major commands
   :bnew¦          create new tab on first available abbreviation
   :bmake ¢¦       create new tab on abbreviation ¢
   :bfree ¢¦       remove tab on abbreviation ¢
   :btitle·´´´¦    rename current buffer
   :bmax·Ë¦        update max number of buffers
   :bsize·´´´¦     set size of current buffer
   :defwide·Ë¦     default col width
   :deftall·Ë¦     default row height
   :defdeep·Ë¦     default layer thickness



.SH VISUAL selection (micro-mode)
.SS ---basics---------------------------------------------------------
 v          start visual selection
 ....y      change selection then perform a common action, like yank
.SS ---overview-------------------------------------------------------
.B situation (S).  
selecting a contiguous group of objects for common treatment is critical for
speed, reliability, and efficiency.

.B complication (C).  
this feature is normally very simplistic, non-standard, troublesome, and
mouse driven.  terrible for advanced users.

.B answer (A).  
standardize on the vi/vim base, generalize to handle all applications, and
make it universal across my applications.
.SS ---full capabilities------------------------------------------------------
.B initiation and termination
   v          turn on selection
   ¥          clear selection (can use proactively with no regrets)

.B updating selection size
   you remain in map mode, so all movement keys are still available
   v          reverses the selection ends to help grow/shrink

.B special adjustments to selection
   ex         selects full range of x
   ey         selects full range of y
   ez         selects full range of z
   e!         selects screen contents
   e*         selects all x,y,z for current buffer

.B normal actions
   y          yank/copy
   Y          yank/clear
   "¢         select a register for use

.B selection saving and retrieving
   there are 86 possible saved selections [a-zA-Z0-9è-ÿ]
   M¢         mark/save the current selection (while selected)
   V¢         move to and highlight the saved selection
   V'         re-select the last area selected

.B additional features
   M?¢        show all saved selections, then save current as ¢
   V?¢        show all saved selections, then goto existing ¢
   V! or M!   change status line to debug current selection details

.B keys reserved ... [vMV]

.SH MAP REGISTERS (sub-mode)
.SS ---basics---------------------------------------------------------
 "ay        copy current visual selection to register 'a'
 "ap        past contents of register 'a' to current position
.SS ---overview-------------------------------------------------------
.B definition (D).  
object registers are temporary holding places for objects and their contents
in order to facilitate movement, transformation, duplication, import/export,
and scripting.

.B value (V).   
moving data between locations while editing is absolutely critical; driving
speed, accuracy, and efficiency.  it allows advanced data movements,
transformations, and advanced scripting.

.B complication (C).  
when provided, it is usually a single, shared, generic desktop clipboard for
cut, copy, and paste. fitting most users.  this neglects all advanced uses
and automation.

.B answer (A).  
i will standardize "mostly" on the excellent vim register standard, and
make it absolutely universal while adding flexible import/export and sepated
text registers.

.B top five requirements (5) to get it right
   -- must be very quick and simple to justify usage
   -- easy user interface that can be universally used
   -- must allow for multiple registers to be flexible
   -- accomodate import and export of data
   -- standard/compatible with text registers in source mode
.SS ---full capabilities------------------------------------------------------
.B invoking object register sub-mode
   "          called from map or visual mode
   ¥          return to previous mode

.B object register list (39)
   /*---(named)-----------------------*/
   a-z        named registers, always overwrites existing data
   A-Z        named registers, appends to existing data (not implemented)
   /*---(special)---------------------*/
   <none>     current selection or location
   $          all content on current tab
   "          unnamed, default register
   +          import from vi/vim clipboard  (~/z_gehye/vi_clip.txt)
   -          export to vi/vim clipboard    (~/z_gehye/vi_clip.txt)
   >          read from shared desktop clipboard (NOT IMPLEMENTED)
   <          send to shared desktop clipboard (NOT IMPLEMENTED)

.B identify register for action
   "a         select register 'a' (single action)
   "A         select register 'a' (single action), but in append mode
   "-         select the vi/vim sharing file

.B most basic register actions (work without register reference)
   y          yank/copy  to register
   d¢         delete/cut to register (fill from ¢ direction)
   x¢         clear/copy to register (fill with nothing)
   a¢         append/insert space (push in ¢ direction)
   p          paste after current position
   P          paste before current position


   a A        append after
   i I        insert before  ("ai inserts register before)
   o O        over/under
   y Y        yank/copy to selected register, cursor stays at end
   d D        delete/cut to selected register, cursor stays at beg
   x X        clear content without making a copy
   r R        replace content (char-by-char)
   s S        substitute content (delete then insert)
   p P        paste content from selected register after cursor

.B multiple paste
   if a cell of data is in register and an area is selected
   if a column of data is in register and a single row is selected
   if a row of data is in register and a single column is selected

.B pulling data from registers (TEXT/SOURCE MODE)
   p  (m)     paste content from selected register over current position

.B maintaining registers
   #          clear selected register, no effect on other data
   *          clear all registers
   g          reselect register area (go)

.B showing and debugging all registers
   "!         shows current register on the status line
   "?         shows a list of all the registers with critical info

.B +/- regs, reading or writing data to vi_clip.txt
   ---examples---------------------
   "-v        writes   format 'v' from selected area
   "c-t       writes   format 't' from register 'c'
   "+v        reads in format 'v' starting at current location
   "f+c       reads in format 'c' into register 'f'
   ---visual-----------------------
   v s        pure-columnar  , printables , untrimmed , with empties
   V S        pure-columnar  , printables , untrimmed , with empties
   ---sources----------------------
   s          separate lines , sources    , trimmed   , no empties
   S          separate lines , (prepended addresses)
   f          file format    , address and source only
   F          file format    , complete
   ---exchange---------------------
   c          standard-csv   , printables , trimmed   , with empties
   C          standard-csv   , sources    , trimmed   , with empties
   t          tab-delimited  , printables , trimmed   , with empties
   T          tab-delimited  , sources    , trimmed   , with empties
   r          ascii-records  , printables , untrimmed , with empties
   R          ascii-records  , sources    , untrimmed , with empties
   ---other------------------------
   p          post-script

.B + regs, reading vi_clip.txt
   v          pure-columnar  , printables only, no adjust
   s          space-delimited, sources or printables, no adjust
   c          standard-csv   , sources or printables, no adjust
   t          tab-delimited  , sources or printables, no adjust
   r          ascii-records  , sources or printables, no adjust
   V          same as v only column widths adjust (sizer only)
   S C T R    same as s, c, t, r only column widths adjust/sizer



.B who knows ???
   d          delete                 CELL_erase ()
   x          cut to register        REG_cut    ()
   y          copy to register       REG_copy   ()
   p          paste from register    REG_paste  ()
   Y                                 REG_valuesout ()

.B actions on data (1 or 3 chars)
   ["x]d      delete/cut from content and overwrite register <x>
   ["x]D      delete/cut as displayed and overwrite register <x>
   ["x]y      yank/copy from content and overwrite register <x>
   ["x]Y      yank/copy as displayed and overwrite register <x>
   ["x]p      paste (into empty space) from register <x> back into the data
   ["x]r      replace (over existing) from register <x> back into the data
   ["x]i      insert before (push left) from register <x> back into the data
   ["x]a      insert after (push right) from register <x> back into the data
   ["x]O      insert above (push up) from register <x> back into the data
   ["x]o      insert below (push down) from register <x> back into the data
   ["x]?      display contents of register <x> on command line

.B actions on registers only
   "x2y       copy from register <x> into register <y>
   "-2x       delete contents of register <x>
   "#         save registers to a file







.B unimplemented vim features
   :reg       to list registers (included in "?)


   -- delete/clear a register
   -- append one register to another
   -- list registers with contents
   -- load a register from an outside file
   -- save a register outside to a file



   v          visual selection
   V          visual cummulative selection
   gv         go to previous selection
   y          yank (fresh)
   Y          yank (append)
   p          paste (into open area)
   P          paste over
   x          cut for later integration
   X          cut and leave absolute connections
   d          delete and do no copy into register
   #a         delete contents of a register
   )a         copy the current register into the new one
   >a         move the current register into the new one
   ]a         append the current register to the new one


.SH EXIM (export/import) pseudo-mode
.B definition (d).  
sharing ascii data with other tools by exporting to shared file in a standard
format and importing elsewhere.

.B current (c).
concept is quite standard, but environments have proprietary tools and formats
for common use.  general sharing is spotty.

.B standard formats (upper case means hinting/auto-adjust)
   v V        exact printable values in table (great for parsing)
   d D        exact printable values with § between values
   f F        trimmed printable values with § between values
   c C        trimmed comma separated values of printables
   t T        trimmed tab delimited printables
   r R        full modified values ready for formatting/printing
   s S        source values (meaning actual formulas too)
   n N        native application format for full data formatting too


.B +/- regs, reading or writing data to vi_clip.txt
   ---examples---------------------
   "-v        writes   format 'v' from selected area
   "c-t       writes   format 't' from register 'c'
   "+v        reads in format 'v' starting at current location
   "f+c       reads in format 'c' into register 'f'
   ---visual-----------------------
   v s        pure-columnar  , printables , untrimmed , with empties
   V S        pure-columnar  , printables , untrimmed , with empties
   ---sources----------------------
   s          separate lines , sources    , trimmed   , no empties
   S          separate lines , (prepended addresses)
   f          file format    , address and source only
   F          file format    , complete
   ---exchange---------------------
   c          standard-csv   , printables , trimmed   , with empties
   C          standard-csv   , sources    , trimmed   , with empties
   t          tab-delimited  , printables , trimmed   , with empties
   T          tab-delimited  , sources    , trimmed   , with empties
   r          ascii-records  , printables , untrimmed , with empties
   R          ascii-records  , sources    , untrimmed , with empties
   ---other------------------------
   p          post-script

.B + regs, reading vi_clip.txt
   v          pure-columnar  , printables only, no adjust
   s          space-delimited, sources or printables, no adjust
   c          standard-csv   , sources or printables, no adjust
   t          tab-delimited  , sources or printables, no adjust
   r          ascii-records  , sources or printables, no adjust
   V          same as v only column widths adjust (sizer only)
   S C T R    same as s, c, t, r only column widths adjust/sizer








.B scripting language.  
interpretive programming languages that act as rapid development environments
to glue programs together.  examples include, bourne-shell, awk, perl, python,
java, etc.

.B extension languages.  
interpretive programming mini-languages that allow the capabilities of
a program to be extended beyond its original purpose.  expamples include,
guile, lua, scheme, lisp, etc.

.B macro language.  
interpretive programming that can access all user capabilitys and exposes
more complicated features to allow automation.  examples include, vim scripts,
lotus 123 macros, etc.


.SH PROGRESS MODE
.B situation.  
some applications provide the ability to view actions and output over time,
i.e., the fourth dimension, including, video, audio, visualization, and
simulation.

.B complication.  
applications that provide progress, time, or sequences typically use timelines,
but actions on timelines tend to be highly varied, simplistic, and mouse-based.
the result is that these interfaces tend to keep things too simple and weak.

.B answer.  
i will add a new mode specifically for progress/timeline viewing and
manipulation.  it will built on the base of vi-keys normal/map mode movements
and add many advanced vi/vim functions.

.B overview.  
progress mode will be based on a timeline, have extended play controls, and
all complex interactions, marking, selection, registers, and other abilities.
this ability is critical and will be treated as such.

.B invoking progress mode
   ,p         enter progress bar mode where it shows in addition to others
   ,P         enter full progress mode for sequencing multiple timelines
   ,,         back to main mode

.B horizontal movement
   0          beginning
   H          left/back five
   h          left/back
   <bs>       pause, and step frame or tiny bit backward
   <sp>       pause, and step frame or tiny bit forward
   l          right/fore
   L          right/fore five
   $          ending

.B vertical movement (between timelines)
   _          top-most
   K          up five
   k          up
   j          down
   J          down five
   ~          bottom-most (same symbol as null lines at bottom of vim

.B scale controls
   i          zoom-in
   o          zoom-out

.B play and speed controls
   +          faster
   .          play/pause
   -          slower

.B current bar alignment (uses the standard shcle codes)
   ^          prefix control code for alignment
   ^0         edge   (0.00)  extreme and unlikely
   ^s         start  (0.05)
   ^h         left   (0.28)
   ^c         center (0.50)
   ^l         rignt  (0.72)
   ^e         end    (0.95)
   ^$         edge   (1.00)  extreme and unlikely
   -- ^ was vim for first character on the line (under utilized)

.B special controls
   #          write diagnostic information

.B TBC (to be created)
   marks using m and '
   visual selections
   registers for cut, copy, paste
   ecgz commands for horizontal movement
   move to a specific time
   commands to set progress bar to stay at five positions (shcle)
   command to heighten and shorten progress window when multiple lines used
   grouping and ungrouping to make "blocks" of content









.SH GOD MODE
.B situation.  
some applications provide the ability to view and/or manipulate in three or
four (time) dimensions, e.g., modeling and robotics.  the faster and cleaner
the better so that this three-dimensional ability becomes useful.

.B complication.  
all applications using four-dimensions use different interfaces and shortcuts.
each one provides completely different capabilities.  and, they are all
hampered by trying to keep it very simple.


.B answer.  
add a new mode specifically for four-dimensional viewing and manipulation.
build it on the base of vi-keys normal/map mode movements, but clear out the
other keys to make room for complex interactions.

.B linear movements
   0HhlL$

.B source mode 1D vertical movements
   _          beginning of entry
   K          up 5 lines
   k          up 1 line
   j          right 1 line
   J          right 5 lines
   ~          bottom-most (same symbol as null lines at bottom of vim













.SH UNIVERSAL

   :          command mode
   <esc>      normal mode
   v          visual mode
   "          registers           (existing)
   m '        marks               (existing)
   q @        macros and scripts  (existing)
   M ;        hints               (new)
   c          <control>           (new)
   \          <alt> or <menu>     (new)
   /          search              (existing)
   f          close search
   *          search for current  (existing)
   nN         continue search     (existing)
   !          filter
   %          matching
   uU         undo
   pP         paste
   y          yank
   dD         delete
   xX         delete
   aA         append/add
   iI         insert
   rR         replace


.SH UNIVERSAL NEW ONES
   ,          windows/tabs
   t          tags
   ?          definition/prototype/etc
   F f        data formatting (very, very useful)
   +          enter positive numerical data
   -          enter negative numerical data
   =          enter a formula
   #          enter note, comment, or string formula
   s          quick data input








registers provide a temporary holding place for data in order to facilitate
movement between different locations in the larger data set or between
applications.  when provided, most applications allow access to the single
desttop clipboard for cut, copy, and paste.  this fits the requirements of
a vast majority of all users.

.B situation (S)




.SH DATA FORMATTING (sub-mode)
.SS ---basics---------------------------------------------------------
 F·f2·|·¥    change to floating point, 2 decimals, and centered
.SS ---overview-------------------------------------------------------
.B define (D)
changing the presentation (not the value) of data with delimiters, units of
measure, spacing, alignments, etc.

.B value (V)
helps users digest, compare, connect, and generate insights leading to clearer,
better, and more decisive decisions.

.B situation (S)
well explored area with many standard formats for various specialities, e.g.,
accountants, engineers, scientists, etc.

.B concern (S)
these capabilities are uniquely supported by each application making their
use inconsistent and spotty.

.B choice (R)
provide standard data formats across my applications based on lessons learned
in mathmatics, management, and statistics.
.SS ---full capabilities----------------------------------------------

.B invoking data formatting
   F          format sub-mode
   ¥ or ¦     return to normal mode (no difference)
   f          single-change format mode that automatically exits

.B horizontal alignment
   < [ { :    left, with [, [ indent, or colon
   > ] } '    right, with [, [ indent, or colon
   | ^        center, with [

.B numeric
   /*---(normal)-----------------------*/
   i          integer (capital is indented)
   f          real/float
   , c s a $  real/float with commas, signed comma, acct, currency
   F          add unit-of-measure scaling to real/floats
   p          percentage (shows a tailing 'p' as '%' is problematic
   /*---(technical)--------------------*/
   e          exponential (E means with spaces)
   ;          technical (commas, decimal commas, signs)
   x          hexadecimal (X means with separators every byte)
   b          binary (B means with separators every four bits)
   o          octal (O means with separators every byte)
   z          mongo (base-62)
   r          roman (R means upper case)
   /*---(time)-------------------------*/
   t d T D    time, date, timestamp, time and date
   /*---(other)------------------------*/
   P          point/bullet

.B decimals
   0-9        number of decimals shown

.B filler for strings
   !          empty fill (default)
   - = _      basic fills
   . @ / +    extended space (@/+ means symbol every three/five)
   ~ #        ruler (very cool) or number scale
   q Q        two kinds of arrows (both ways)

.B column widths (9 options)
   h l        change by single unit
   H L        change by units of five
   m          minimal
   n N        normal and normal-plus
   w W        wide and very wide

.B row heights (4 options)
   j k        change by single unit
   J K        change by units of five



.SH OBJECT SIZING

.B invoking object sizing
   S          sizing mode
   <cr>       return to normal mode

.B widths
   L          smaller by five
   l          smaller by one
   h          bigger by one
   H          bigger by five

.B heights
   J          smaller by five
   j          smaller by one
   h          bigger by one
   H          bigger by five

.B merging (not grouping)
   M


   /*---(fixed)------------------------*/
   m          minimal
   n          normal
   N          normal+
   w          wide
   W          very wide
   /*---(adjustments)------------------*/




.SH SOURCE REGISTERS (sub-mode SREG)
.SS ---basics---------------------------------------------------------
 qa...q     record live keystrokes ... into macro 'a'
 @a         execute macro 'a' from current position
.SS ---overview-------------------------------------------------------
.B definition (D).  
source registers are fast, simple holding places for textual content when it
is being copied, moved, and/or manipulated.

.B value (V).  
moving, copying, and manipulatng data without retyping saves time and mistakes,
especially in complex sequencial actions.

.B situation (S).  
source registers are well and long established, explored, tested, and used
in data editing applications.

.B complication (C).  
given modern limited-experience user focus, registers and their productivity
have be reduced to a single clipboard.

.B answer (A).  
i want these productivity gains badly.  all my applications will have a
powerful and vim-ish set of source registers.

.B extras (E).  
source registers can be directly defined, copied internally, and merged back
into the data in additional ways.
.SS ---full capabilities----------------------------------------------

.B register list (27 common, 61 total)
   "          unnamed, default register
   a-z        lower case (26), are common, interactive use
   A-Z (*)    alternate name for lower case, signifies append
   0-9        numeric (10) internal use by the system
   è-ÿ        greek (24) are holders for complicated scripting

.B identify register for action
   "a         select register 'a' (single action)
   "A         select register 'a' (single action), but in append mode

.B pushing data into registers
   y          yank/copy  content to selected register
   d          delete/cut content to selected register
   x          clear/copy content to selected register
   #          clear selected register, no effect on other data

.B pulling data from registers (TEXT/SOURCE MODE)
   p          paste register content after cursor
   P          paste register content before cursor
   r, R       replace text with register content starting at cursor

.B maintaining registers

.B debugging and observing
   "¢_        tracks register ¢ on the status line
   "?         shows a list of all the registers with critical info

.B manipulating source registers at command line
   :sreg a¦             purge lower case registers (also 0 and è)
   :sreg h=¦            clears register h
   :sreg h=´´´¦         directly input and save the register
   :sreg i="´´´"¦       allows ¦ (ret) and ¥ (esc)
   :sreg i=\\n\\e¦        also allows ¦ (ret) and ¥ (esc)
   :sreg j=\\"´´´¦       escaped quote can go anywhere
   :sreg j="´´´¦        leading " allowed if no final "
   :sreg J="´´´"¦       appends to existing register 'j'
   all leading, internal, and trailing whitespace is meaningful

.B moving and copying registers at command line
   :sreg ab¦            copies 'b' into macro 'a'
   :sreg Ab¦            appends 'b' unto end of macro 'a'
   :sreg a-¦            exports keys to vi_clip.txt
   :sreg a+¦            imports keys from vi_clip.txt
   :sreg A+¦            appends keys from vi_clip.txt
   :dump sreg¦          lists all registers in vi_clip.txt







.SH TEXT REPLACEMENT/OVERTYPE (sub-mode REPLACE)

.B situation.  
often creators and editors require quick, selective replacement of text
in-place or overtyping.  this is a frequent activity and allows much more
surgical, accurate, and quick updates.

.B complication.  
most applications just don't provide this.  they require text to be deleted
and new text re-added.  this causes many issues, including, changing too many
characters, altering line lengths, and requiring great short-term memory ;)

.B answer.  
we will standardize around the vi/vim replace mode.  done.

.B overview.  
text replacement is called from source mode and has two flavors -- single and
contiguous character overtype.

.B special look or formatting
   1) special placeholder character will show current insertion point
   2) editing area will have a unique color indicating replace mode
   3) message line will display mode and helpful hints

.B single character changes
   r<c>       replace char under the cursor with <c>
   r<es>      abort change early without change
   r<cr>      abort change early without change

.B contiguous character changes
   R          switches to replace sub-mode
   <c>        replace char under cursor with <c>, and move cursor right
   <bs>       backspace puts the character back and moves left
   <es>       escape accepts change and exits replace mode
   <cr>       return accepts change and exits replace mode

.B notes.  
   1) all control characters (0 - 31, 127) are filtered out
   2) contiguous mode will go beyond end-of-line with no issues


.SH HORIZONTAL


.SH SOURCE MODE (SELECT, REPLACE, and INPUT)
.B situation.  
the ability to create, review, and change lines of text is fundamental to all
important applications.  the focus must be on speed, accuracy, and efficiency
since it happens with such frequency.

.B complication.  
modern applications are typically optimized for review, not creation.
editing is non-standard, requiring mice to position the cursor, keyboards to
make changes, and buttons to select fields.

.B answer.  
we will standardize around a modal, keyboard-centric, simplified, vim-like
model which allows the user to edit quickly and easily.

.B overview.  
source mode allows the user to review, move, and delete text; input mode allows
them to add new text, and replace mode allows them to overtype exising text.

.B source mode horizontal movements
   0 HhlL $      horizontal
   g SHshcleLE   goto horizontal
   z shcle       scroll horizontal
   ^ shcle       scroll lock


.SH SOURCE mode

.B standard horizontal movements
   0HhlL$        move and adjust screen as required
   g + shcle     goto a point in the available display space
   z + shcle     scroll current position to a point in display space
   g + SHLE      0.5 and 1.0 page moves left and right
   wWeEbB        word based movements
   Æ|            specific character position

.B undo and redo (separate from map mode undo/redo)
   u             undo last update
   U             redo last update

.B character searches
   f¢            search forward for character ¢
   F¢            search backward for character ¢
   n             next match forward
   N             next match backward
   #             search forward for current character
   found character is saved between searches for quick reuse

.B delete, clear, and change
   ¿             deletes the previous character
   ¾             deletes the current character
   d + hlwbe0$   delete a character(s) in the given direction
   x + hlwbe0$   clear a character(s) in the given direction
   c + hlwbe0$   delete a character(s) then enter input micro-mode
   D             shortcut for dl
   X             shortcut for xl

.B inputing new text (INPUT micro-mode)
   i             insert before current character
   a             append after current character
   I             insert at end-of-line
   A             append to beginning-of-line

.B replacing existing text (REPLACE micro-mode)
   r             replace current position (exits automatically)
   R             replace a string of characters until exiting

.B repeats and counts
   Ë             all commands can take a prefixed count

.SH INPUT micro-mode
.SS ---basics---------------------------------------------------------
 i...¥     insert text before the current character
.SS ---overview-------------------------------------------------------
.B purpose.  
fast, unincumbered, free-form, thought-free typing is critical to any text
entry/creation task.

.B complication.  
many applications attempt to mix creation, editing, and formatting all in a
single editing context.

.B answer.  
standardize on a simplified vim-modal interface that separates input from
editing and review for speed.

.B NOTE.  
all text entry uses this input micro-mode, it is universal.
.SS ---full capabilities----------------------------------------------

.B invoking input mode from source mode
   i          insert before current character
   a          append after current character
   I          insert at end-of-line
   A          append to beginning-of-line

.B placeholder display
   ¤          placeholder where next character will go
   this character is temporary and will not be saved

.B control characters
   ¥          return to source mode for further editing
   ¦          accept all changes and exit source mode also
   ¿          delete the character before the current one
   ¾          delete the current character
   \\          allows entry of special characters (see below)

.B adding special characters and controls (see SPECIAL CHARACTERS)

.B insert specification
   -- moves current char (and rest) one to the left, adding to the length
   -- current chacrcter made into a ¤
   -- each new character current location and ¤ shifted right
   -- ¦ and ¥ both remove ¤ and collapse its location
   -- ¦ saves all changes, executes if needed, and returns to map mode
   -- ¥ saves all changes, returns to source mode, current is last char added


.SH REPLACE micro-mode
.SS ---basics---------------------------------------------------------
 r½      replace the current character in source mode
.SS ---overview-------------------------------------------------------
.B purpose.  
to speed text editing, replace provides a very rapid type-over of existing
characters to fix small typing mistakes.

.B complication.  
many applications require two steps, first delete or highlight the mistake,
then type the new text.

.B answer.  
standardize on a simplified vim-modal interface that includes this rapid
short-hand for type-over.

.B NOTE.  
all text includes uses this replace micro-mode, it is universal.
.SS ---full capabilities----------------------------------------------

.B invoking input mode from source mode
   r          replace current position (exits automatically)
   R          replace a string of characters until exiting

.B placeholder display
   ¤          placeholder shows what position will be replaced
   this character is temporary and will not be saved

.B control characters
   ¥          return to source mode for further editing
   ¦          all accept changes and exit source mode also
   Å          move one character left  (leave character)
   Ä          move one character right (leave character)
   \\          allows entry of special characters (same as input)

.B single replace
   r½
   Ær½
   R½½½¥

.SH ENDS and EDGES
.B situation (S).  
the ability to navigate quickly from one break or discontinuity to the
next allows creators and editors to quickly explore, identify, and manage
transitions.

.B complication (C).  
this is a consistently neglected feature in applications.  usually, a user
must manually step through content, or, rely on an pre-existing index or
table of contents.

.B answer (A).  
vim has a inherently one-dimensional view of the world ;) but, we can make
it a great foundation for a three-dimensional end and edge finding system when
combined with lotus 123 end finding.

.B overview (O).  
end and edge movements allow the creator and editor to quickly explore their
full environment and move to critical breaks and transition points without
prior knowledge of their locations.

.B primary modifier key
   e          end/edge

.B standard, universal movement suffix keys
   shcle x    horizontal (x)
   tkmjb y    vertical (y)
   nopif z    depth (z)
   azud       corners
   gqrv       unused
   *          all on tab/area
   !          all on screen

.B horizontal (x-axis)...    e + [SsHhCcLlEe]
   eS         edge/leftmost start of all allowed space
   eH         edge/maximum leftmost edge of any row/line
   es         edge/maximum leftmost edge in this row/line
   eh         next normal break to the left
   ec         horizontal center of current block
   eC         horizontal center of all used space
   el         next normal break to the right
   ee         edge/maximum rightmost edge in this row/line
   eL         edge/maximum rightmost edge of any row/line
   eE         edge/rightmost end of all allowed space

.B vertical (y-axis)...      e + [TtKkMmJjBb]
   eT         edge/topmost start of all allowed space
   eK         edge/maximum topmost edge of any col/line
   et         edge/maximum topmost edge in this col/line
   ek         next normal break to the top
   em         vertical center of current block
   eM         vertical center of all used space
   ej         next normal break to the bottom
   eb         edge/maximum bottommost edge in this col/line
   eJ         edge/maximum bottommost edge of any col/line
   eB         edge/bottommost end of all allowed space

.B depth (z-axis)...         e + [NnOopPiIfF]
   eN         edge/nearest start of all allowed space
   eO         edge/maximum nearest edge of any col/line
   en         edge/maximum nearest edge in this col/line
   eo         next normal break to the nearside
   ep         depth center of current block
   eP         depth center of all used space
   ei         next normal break to the farside
   ef         edge/maximum farthest edge in this col/line
   eI         edge/maximum farthest edge of any col/line
   eF         edge/farthest end of all allowed space

.B center of contiguous space
   eC         horizontal center of all available space
   ec         horizontal center of used space
   eM         vertical center of all available space
   em         vertical center of used space
   eP         depth center of all available space
   ep         depth center of used space

.B 2d corners...             e + [aAuUzZdD]
   eA         top-left edge of all available space
   ea         top-left edge of all used space
   eU         top-right edge of all available space
   eu         top-right edge of all used space
   eZ         bottom-right edge of all available space
   ez         bottom-right edge of all used space
   eD         bottom-left edge of all available space
   ed         bottom-left edge of all used space

.B within one-dimensional source mode
   w, W       next word
   b, B       beginning of word
   e, E       end of word

.B within video or audio type streams
   <          left any break                                   [[ ------ ]]
   >          right any break                                  [[ ------ ]]
   (          left small break                                 [[ ------ ]]
   )          right small break                                [[ ------ ]]
   {          left big break                                   [[ ------ ]]
   }          right big break                                  [[ ------ ]]

.SH GOTO and SCROLL
.B situation.  
jumping quickly between areas of the screen is critical for rapid creation
and editing.  additionally, scrolling or sliding the screen content, instead
of just moving, helps maintain context while jumping.

.B complication.  
modern applications rely on hard to reach arrow and page keys, as well as
mouse movement to alter screen position.  any of these methods slows the
editor down considerably and requires a context shift.

.B answer.  
we will take the vi/vim movements for both jumping and scrolling, but apply
a more consistent key assignment as vim uses a very inconsistent combination
of keystrokes.

.B primary modifier keys
   g          goto                                              [[ prefix ]]
   z          scroll                                            [[ prefix ]]

.B standard, universal movement keys
   hlkjoi     six directions along three axis
   setbnf     start, end, top, bottom, near, far
   azud       alpha, omega, upper-right, down-left
   cm.+       center, middle, front-back, full center
   w          wordish

.B horizontal movement/scrolling
   gS         go a full screen/page to the left
   gH         go a half screen/page to the left
   gs (zs)    go (scroll current) left end of screen            [[ sleep  ]]
   gh (zh)    go (scroll current) left quarter of screen        [[ select ]]
   gc (zc)    go (scroll current) center of screen              [[        ]]
   gl (zl)    go (scroll current) right quarter of screen       [[        ]]
   ge (ze)    go (scroll current) right end of screen           [[ word   ]]
   gL         go a half screen/page to the right
   gE         go a full screen/page to the right

.B vertical movement/scrolling
   gT         go a full screen/page upwards
   gK         go a half screen/page upwards
   gt (zt)    go (scroll current) top end of screen             [[ n.tab  ]]
   gk (zk)    go (scroll current) top quarter of screen         [[ wrap.k ]]
   gm (zm)    go (scroll current) middle of screen              [[ middle ]]
   gj (zj)    go (scroll current) bottom quarter of screen      [[ wrap.j ]]
   gb (zb)    go (scroll current) bottom end of screen          [[        ]]
   gJ         go a half screen/page downwards
   gB         go a full screen/page downwards

.B corner movement/scrolling
   ga (za)    go (scroll current) top-left corner (alpha)       [[ ascii  ]]
   gu (zu)    go (scroll current) top-right corner (near)       [[ next   ]]
   gz (zz)    go (scroll current) bottom-right corner (omega)   [[ byte   ]]
   gd (zd)    go (scroll current) bottom-left corner (far)      [[ file   ]]
   g. (z.)    go (scroll current) center of screen              [[        ]]
   gA (zA)    go half page up and left    (gK + gH)             [[        ]]
   gU (zU)    go half page up and right   (gK + gL)             [[        ]]
   gZ (zZ)    go half page down and right (gJ + gL)             [[        ]]
   gD (zD)    go half page down and left  (gJ + gH)             [[        ]]

.B vi/vim key collisions -- NONE of any importance


.SH HORIZONTAL MOVEMENT (x-axis)

horizontal/x-axis movement is fundamental to almost every visual application,
including textual user interfaces (like vim) and graphical user interfaces,
as well as command-line editing and many others.

.B primary keys involved
   h l         left and right
   (cegz) s e  start and end, only for use with cegz prefixes

primary keys are 'h' (left) and 'l' (right).  suffix keys are 'e' (start)
and 'e' (end).  rotation keys are 'y' (yaw) and 't' (turn).

.B simple movement, move cursor, but not screen
   0          beginning of line/bounded space                  [[ ------ ]]
   H          left 5 char/units                                [[ yes    ]]
   h          left 1 char/units                                [[ ------ ]]
   l          right 1 char/units                               [[ ------ ]]
   L          right 5 char/units                               [[ yes    ]]
   $          ending of line/bounded space                     [[ ------ ]]

.B move screen and cursor
   cs         left a page                                      [[ good   ]]
   ch         left a half page                                 [[ good   ]]
   cl         right a half page                                [[ !!!!!! ]]
   ce         right a full page                                [[ good   ]]

.B move cursor to a part of the screen (no screen movement)
   gs         left edge of screen                              [[ good   ]]
   gh         left quarter of screen                           [[ good   ]]
   gc         center of screen                                 [[ good   ]]
   gl         right quarter of screen                          [[ good   ]]
   ge         right edge of screen                             [[ good   ]]

.B scroll cursor position to a new screen position (no cursor movement)
   zs         left edge of screen                              [[ good   ]]
   zh         left quarter of screen                           [[ good   ]]
   zc         center of screen                                 [[ good   ]]
   zl         right quarter of screen                          [[ good   ]]
   ze         right edge of screen                             [[ good   ]]

.B contiguous area movement (all start with 'e')
   es         left edge of all used space                      [[ ------ ]]
   eH         left edge of close objects/line-of-sight         [[ ------ ]]
   eh         left edge of contiguous area                     [[ ------ ]]
   ec         middle of contiguous area                        [[ ------ ]]
   el         right edge of contiguous area                    [[ ------ ]]
   eL         right edge of close objects/line-of-sight        [[ ------ ]]
   ee         right edge of all used space                     [[ ------ ]]

.B rotations around the y-axis (yaw)
   cv         yaw (veer) leftward 45 deg                       [[ ------ ]]
   V          yaw (veer) leftward 5 deg                        [[ ------ ]]
   v          yaw (veer) leftward 1 deg                        [[ ------ ]]
   y          yaw rightward 1 deg                              [[ ------ ]]
   Y          yaw rightward 5 deg                              [[ ------ ]]
   cy         yaw rightward 45 deg                             [[ ------ ]]

.SH VERTICAL MOVEMENT (y-axis)

vertical/y-axis movement is fundamental to almost every visual application,
including textual user interfaces (like vim) and graphical user interfaces,
as well as command-line editing and many others.

primary keys are 'j' (down) and 'k' (up).  suffix keys are 't' (top)
and 'b' (bottom).  rotation keys are 'u' (up) and 'd' (down).

.B simple movement, move cursor, but not screen
   _          beginning of line/bounded space                  [[ good   ]]
   K          up 5 char/units                                  [[ !!!!!! ]]
   k          up 1 char/units                                  [[ ------ ]]
   j          down 1 char/units                                [[ ------ ]]
   J          down 5 char/units                                [[ !!!!!! ]]
   ~          ending of line/bounded space                     [[ good   ]]

.B move screen and cursor
   ct         up a page                                        [[ good   ]]
   ck         up a half page                                   [[ good   ]]
   cj         down a half page                                 [[ good   ]]
   cb         down a full page                                 [[ good   ]]

.B move cursor to a part of the screen (no screen movement)
   gt         top edge of screen                               [[ yes    ]]
   gk         top quarter of screen                            [[ good   ]]
   g.         middle of screen                                 [[ good   ]]
   gj         bottom quarter of screen                         [[ good   ]]
   gb         bottom edge of screen                            [[ good   ]]

.B scroll cursor position to a new screen position (no cursor movement)
   zt         top edge of screen                               [[ ------ ]]
   zk         top quarter of screen                            [[ good   ]]
   z.         middle of screen                                 [[ ------ ]]
   zj         bottom quarter of screen                         [[ good   ]]
   zb         bottom edge of screen                            [[ ------ ]]

.B contiguous area movement (all start with 'e')
   e_         top edge of all used space                       [[ ------ ]]
   et         top edge of close objects/line-of-sight          [[ ------ ]]
   ek         top edge of contiguous area                      [[ ------ ]]
   e.         middle of contiguous area                        [[ ------ ]]
   ej         bottom edge of contiguous area                   [[ ------ ]]
   eb         bottom edge of close objects/line-of-sight       [[ ------ ]]
   eg         bottom edge of all used space                    [[ ------ ]]

.B rotations about the x-axis (pitch)
   ca         pitch (ascend) upward 45 deg                     [[ ------ ]]
   A          pitch (ascend) upward 5 deg                      [[ ------ ]]
   a          pitch (ascend) upward 1 deg                      [[ ------ ]]
   p          pitch (plunge) downward 1 deg                    [[ ------ ]]
   P          pitch (plunge) downward 5 deg                    [[ ------ ]]
   cP         pitch (plunge) downward 45 deg                   [[ ------ ]]

.SH ZOOMING MOVEMENT (z-axis)

zooming/z-axis movement is fundamental to almost every visual application,
including textual user interfaces (like vim) and graphical user interfaces,
as well as command-line editing and many others.

.B primary keys involved
   i o        inward (pushing in) and outward (pulling out)
   c e g z    standard prefix keys
   n f        near and far, suffix keys for cegz
   r s        rotate right and spin left around z-axis

primary keys are 'i' (in) and 'o' (out).  suffix keys are 'z' (zoom)
and 'a' (away).  rotation keys are 'r' (rotate) and 's' (spin).

.B simple movement, move cursor, but not screen
   g+         beginning of line/bounded space                  [[ ------ ]]
   I          in 5 char/units                                  [[ ------ ]]
   i          in 1 char/units                                  [[ ------ ]]
   o          out 1 char/units                                 [[ ------ ]]
   O          out 5 char/units                                 [[ ------ ]]
   g-         ending of line/bounded space                     [[ ------ ]]

.B move screen and cursor
   cz         in a page                                        [[ ------ ]]
   ci         in a half page                                   [[ ------ ]]
   ci         out a half page                                  [[ ------ ]]
   ca         out a full page                                  [[ ------ ]]

.B move cursor to a part of the screen (no screen movement)
   gz         top edge of screen                               [[ ------ ]]
   gi         top quarter of screen                            [[ ------ ]]
   g#         middle of screen                                 [[ ------ ]]
   go         bottom quarter of screen                         [[ ------ ]]
   ga         bottom edge of screen                            [[ ------ ]]

.B scroll cursor position to a new screen position (no cursor movement)
   zz         top edge of screen                               [[ ------ ]]
   zi         top quarter of screen                            [[ ------ ]]
   z#         middle of screen                                 [[ ------ ]]
   zo         bottom quarter of screen                         [[ ------ ]]
   za         bottom edge of screen                            [[ ------ ]]

.B contiguous area movement (all start with 'e')
   e+         front edge of all used space                     [[ ------ ]]
   ez         front edge of close objects/line-of-sight        [[ ------ ]]
   ek         front edge of contiguous area                    [[ ------ ]]
   e#         middle of contiguous area                        [[ ------ ]]
   eo         after edge of contiguous area                    [[ ------ ]]
   ea         after edge of close objects/line-of-sight        [[ ------ ]]
   e-         after edge of all used space                     [[ ------ ]]

.B rotations about the z-axis (roll)
   cw         roll (wind) counter-clockwise 45 deg             [[ ------ ]]
   W          roll (wind) counter-clockwise 5 deg              [[ ------ ]]
   w          roll (wind) counter-clockwise 1 deg              [[ ------ ]]
   r          roll clockwise 1 deg                             [[ ------ ]]
   R          roll clockwise 5 deg                             [[ ------ ]]
   cr         roll clockwise 45 deg                            [[ ------ ]]

.SH ORIGINAL MAPPINGS

.B normal mode
   C-@        - - - - - - -                                    [[ ------ ]]
   C-a        add <n> to number at/after cursor                [[ ------ ]]
   C-b        scroll <n> screens backward                      [[ ------ ]]
   C-c        interupt current command/search                  [[ useful ]]
   C-d        scroll <n> lines down                            [[ ------ ]]
   C-e        scroll <n> lines upward                          [[ ------ ]]
   C-f        scroll <n> screens forward                       [[ ------ ]]
   C-g        display current filename and position            [[ maybe  ]]
   C-h        dup with 'h'                                     [[ ------ ]]
   C-i        dup with <tab>                                   [[ ------ ]]
   C-j        dup with 'j'                                     [[ ------ ]]
   C-k        - - - - - - -                                    [[ ------ ]]
   C-l        redraw screen                                    [[ useful ]]
   C-m        dup with <cr>                                    [[ ------ ]]
   C-n        dup with 'j'                                     [[ ------ ]]
   C-o        older entry on jump list                         [[ ------ ]]
   C-p        dup with 'k'                                     [[ ------ ]]
   C-q        terminal flow control                            [[ ------ ]]
   C-r        redo changes undone with undo                    [[ useful ]]
   C-s        terminal flow control                            [[ ------ ]]
   C-t        jump to <n> older tag                            [[ ------ ]]
   C-u        scroll <n> lines upward                          [[ ------ ]]
   C-v        blockwise select                                 [[ ------ ]]
   C-w        window command prefix                            [[ useful ]]
   C-x        subtract <n> from number at/after cursor         [[ ------ ]]
   C-y        scroll <n> lines downward                        [[ ------ ]]
   C-z        suspend program and go to shell                  [[ ------ ]]
   <esc>                                                       [[ ------ ]]
   <cr>                                                        [[ ------ ]]
   <bs>                                                        [[ ------ ]]
   !          filter <motion> text thru something              [[ ------ ]]
   "          use a register for next action                   [[ USEFUL ]]
   '          go to a specific mark                            [[ USEFUL ]]
   #          search backwards for what's under cursor         [[ USEFUL ]]
   *          search forewards for what's under cursor         [[ USEFUL ]]
   $          end of line                                      [[ USEFUL ]]
   %          find matching whatever                           [[ USEFUL ]]
   &          repeat last s/                                   [[ USEFUL ]]
   (          scroll <n> sentences upward                      [[ ------ ]]
   )          scroll <n> sentences downward                    [[ ------ ]]
   {          scroll <n> paragraph upward                      [[ ------ ]]
   }          scroll <n> paragraph downward                    [[ ------ ]]
   +          line down                                        [[ ------ ]]
   -          line up                                          [[ ------ ]]
   .          repeat last change at current position           [[ USEFUL ]]
   ,                                                           [[ ------ ]]
   /          search                                           [[ USEFUL ]]
   ?          search backwards                                 [[ USEFUL ]]
   :          enter command mode                               [[ USEFUL ]]
   ;                                                           [[ ------ ]]
   <          shift lines left                                 [[ ------ ]]
   <<         shift lines left                                 [[ ------ ]]
   >          shift lines right                                [[ ------ ]]
   >>         shift lines right                                [[ ------ ]]
   =          put lines through indent                         [[ ------ ]]
   ==         put lines through indent                         [[ ------ ]]
   @          execute a registers contents                     [[ USEFUL ]]
   _          cursor to start of next line                     [[ ------ ]]
   ^          beginning of line                                [[ USEFUL ]]
   |          go to column <n>                                 [[ ------ ]]
   ~          switch case                                      [[ useful ]]
   A          append after text                                [[ useful ]]
   B          backwards <n> WORDS                              [[ ------ ]]
   C          cursor till end-of-line                          [[ ------ ]]
   D          delete till end-of-line                          [[ useful ]]
   E          forwards <n> WORDS                               [[ ------ ]]
   F          find character backwards                         [[ maybe  ]]
   G          cursor to line <n>                               [[ ------ ]]
   H          cursor to line <n> from top of screen            [[ ------ ]]
   I          insert before first char                         [[ useful ]]
   J          join lines                                       [[ useful ]]
   K          lookup keyword under cursor                      [[ maybe  ]]
   L          cursor to line <n> from bottom of screen         [[ ------ ]]
   M          cursor to middle line of screen                  [[ ------ ]]
   N          repeat the latest search in opposite direction   [[ USEFUL ]]
   O          insert a new line above current                  [[ useful ]]
   P          paste text                                       [[ USEFUL ]]
   Q          switch to EX mode                                [[ ------ ]]
   R          replace mode                                     [[ useful ]]
   S          delete lines and start insert                    [[ ------ ]]
   T          cursor till after <char>                         [[ maybe  ]]
   U          undo all changes on current line                 [[ maybe  ]]
   V          start linewise selection                         [[ maybe  ]]
   W          cursor <n> WORDS forward                         [[ ------ ]]
   X          delete chars before cursor                       [[ maybe  ]]
   Y          yank selected lines into buffer                  [[ USEFUL ]]
   Z          - - - - - - -                                    [[ ------ ]]
   a          append after cursor                              [[ useful ]]
   b          cursor back <n> words                            [[ ------ ]]
   c          delete and start intsert                         [[ ------ ]]
   d          delete                                           [[ USEFUL ]]
   e          cursor forward <n> words                         [[ ------ ]]
   f          cursor forward to <char> to the right            [[ maybe  ]]
   g          EXTENDED COMMANDS                                [[ USEFUL ]]
   h          cursor left                                      [[ USEFUL ]]
   i          insert before the cursor                         [[ USEFUL ]]
   j          cursor down                                      [[ USEFUL ]]
   k          cursor up                                        [[ USEFUL ]]
   l          cursor right                                     [[ USEFUL ]]
   m          set a mark                                       [[ USEFUL ]]
   n          next search                                      [[ USEFUL ]]
   o          insert a line after                              [[ useful ]]
   p          paste text after cursor                          [[ useful ]]
   q          record macro                                     [[ USEFUL ]]
   r          replace character                                [[ useful ]]
   s          delete and start insert                          [[ ------ ]]
   t          cursor before <char>                             [[ maybe  ]]
   u          undo                                             [[ USEFUL ]]
   v          characterwise visual select                      [[ useful ]]
   w          cursor <n> words forward                         [[ ------ ]]
   x          delete under cursor                              [[ USEFUL ]]
   y          yank selected text                               [[ USEFUL ]]
   z          EXTENDED                                         [[ USEFUL ]]

.B visual mode
   C-@                                                         [[ ------ ]]
   C-a                                                         [[ ------ ]]
   C-b                                                         [[ ------ ]]
   C-c        stop visual mode (dup of <esc>)                  [[ ------ ]]
   C-d                                                         [[ ------ ]]
   C-e                                                         [[ ------ ]]
   C-f                                                         [[ ------ ]]
   C-g        toggle visual/select modes                       [[ ------ ]]
   C-h        dup of <bs>                                      [[ ------ ]]
   C-i                                                         [[ ------ ]]
   C-j                                                         [[ ------ ]]
   C-k                                                         [[ ------ ]]
   C-l                                                         [[ ------ ]]
   C-m                                                         [[ ------ ]]
   C-n                                                         [[ ------ ]]
   C-o        switch to select mode for one command            [[ ------ ]]
   C-p                                                         [[ ------ ]]
   C-q                                                         [[ ------ ]]
   C-r                                                         [[ ------ ]]
   C-s                                                         [[ ------ ]]
   C-t                                                         [[ ------ ]]
   C-u                                                         [[ ------ ]]
   C-v        switch to blockwise                              [[ ------ ]]
   C-w                                                         [[ ------ ]]
   C-x                                                         [[ ------ ]]
   C-y                                                         [[ ------ ]]
   C-z                                                         [[ ------ ]]
   <esc>      switch to normal mode                            [[ ------ ]]
   <cr>                                                        [[ ------ ]]
   <bs>                                                        [[ ------ ]]
   !          filter highlighted lines                         [[ useful ]]
   "                                                           [[ ------ ]]
   '                                                           [[ ------ ]]
   #                                                           [[ ------ ]]
   *                                                           [[ ------ ]]
   $                                                           [[ ------ ]]
   %                                                           [[ ------ ]]
   &                                                           [[ ------ ]]
   (                                                           [[ ------ ]]
   )                                                           [[ ------ ]]
   {                                                           [[ ------ ]]
   }                                                           [[ ------ ]]
   +                                                           [[ ------ ]]
   -                                                           [[ ------ ]]
   .                                                           [[ ------ ]]
   ,                                                           [[ ------ ]]
   /                                                           [[ ------ ]]
   ?                                                           [[ ------ ]]
   :          command mode with highlighted lines              [[ USEFUL ]]
   ;                                                           [[ ------ ]]
   <          shift highlighted lines                          [[ ------ ]]
   <<                                                          [[ ------ ]]
   >          shift highlighted lines                          [[ ------ ]]
   >>                                                          [[ ------ ]]
   =          filter highlighted lines                         [[ ------ ]]
   ==                                                          [[ ------ ]]
   @                                                           [[ ------ ]]
   |                                                           [[ ------ ]]
   ~          swap case                                        [[ ------ ]]
   A          append same text to all lines at end             [[ ------ ]]
   B                                                           [[ ------ ]]
   C          delete highlighted lines and insert              [[ ------ ]]
   D          delete highlighted lines                         [[ ------ ]]
   E                                                           [[ ------ ]]
   F                                                           [[ ------ ]]
   G                                                           [[ ------ ]]
   H                                                           [[ ------ ]]
   I          insert same text in all lines                    [[ ------ ]]
   J          join highlighted lines                           [[ ------ ]]
   K          lookup keyword                                   [[ ------ ]]
   L                                                           [[ ------ ]]
   M                                                           [[ ------ ]]
   N                                                           [[ ------ ]]
   O          move to other horizontal corner                  [[ ------ ]]
   P                                                           [[ ------ ]]
   Q                                                           [[ ------ ]]
   R          delete highlighted lines and insert              [[ ------ ]]
   S          delete highlighted lines and insert              [[ ------ ]]
   T                                                           [[ ------ ]]
   U          uppercase highlighted area                       [[ ------ ]]
   V          make visual mode linewise                        [[ ------ ]]
   W                                                           [[ ------ ]]
   X          delete highlighted lines                         [[ ------ ]]
   Y          yank highlighted lines                           [[ ------ ]]
   Z                                                           [[ ------ ]]
   a          EXTEND HIGHLIGHTED AREA (special)                [[ ------ ]]
   b                                                           [[ ------ ]]
   c          delete highlighted area and go to insert         [[ ------ ]]
   d          delete highlighted area                          [[ ------ ]]
   e                                                           [[ ------ ]]
   f                                                           [[ ------ ]]
   g                                                           [[ ------ ]]
   h                                                           [[ ------ ]]
   i          EXTEND HIGHLIGHTED AREA (special)                [[ ------ ]]
   j                                                           [[ ------ ]]
   k                                                           [[ ------ ]]
   l                                                           [[ ------ ]]
   m                                                           [[ ------ ]]
   n                                                           [[ ------ ]]
   o          move cursor to the other corner of area          [[ ------ ]]
   p                                                           [[ ------ ]]
   q                                                           [[ ------ ]]
   r          delete highlighted area and start insert         [[ ------ ]]
   s          delete highlighted area and start insert         [[ ------ ]]
   t                                                           [[ ------ ]]
   u          make lower case                                  [[ ------ ]]
   v          switch to characterwise visual mode              [[ ------ ]]
   w                                                           [[ ------ ]]
   x          delete highlighted area and start insert         [[ ------ ]]
   y          yank highlighted area                            [[ ------ ]]
   z                                                           [[ ------ ]]

.B 'g' commands
   gC-@                                                        [[ ------ ]]
   gC-a                                                        [[ ------ ]]
   gC-b                                                        [[ ------ ]]
   gC-c                                                        [[ ------ ]]
   gC-d                                                        [[ ------ ]]
   gC-e                                                        [[ ------ ]]
   gC-f                                                        [[ ------ ]]
   gC-g       information about current cursor position        [[ useful ]]
   gC-h       start select block mode                          [[ ------ ]]
   gC-i                                                        [[ ------ ]]
   gC-j                                                        [[ ------ ]]
   gC-k                                                        [[ ------ ]]
   gC-l                                                        [[ ------ ]]
   gC-m                                                        [[ ------ ]]
   gC-n                                                        [[ ------ ]]
   gC-o                                                        [[ ------ ]]
   gC-p                                                        [[ ------ ]]
   gC-q                                                        [[ ------ ]]
   gC-r                                                        [[ ------ ]]
   gC-s                                                        [[ ------ ]]
   gC-t                                                        [[ ------ ]]
   gC-u                                                        [[ ------ ]]
   gC-v                                                        [[ ------ ]]
   gC-w                                                        [[ ------ ]]
   gC-x                                                        [[ ------ ]]
   gC-y                                                        [[ ------ ]]
   gC-z                                                        [[ ------ ]]
   gA                                                          [[ ------ ]]
   gB                                                          [[ ------ ]]
   gC                                                          [[ ------ ]]
   gD         do to definition of word under cursor            [[ useful ]]
   gE         like E                                           [[ ------ ]]
   gF                                                          [[ ------ ]]
   gG                                                          [[ ------ ]]
   gH         start select line mode                           [[ ------ ]]
   gI         like I                                           [[ ------ ]]
   gJ         like join lines                                  [[ ------ ]]
   gK                                                          [[ ------ ]]
   gL                                                          [[ ------ ]]
   gM                                                          [[ ------ ]]
   gN         like N                                           [[ ------ ]]
   gO                                                          [[ ------ ]]
   gP                                                          [[ ------ ]]
   gQ                                                          [[ ------ ]]
   gR                                                          [[ ------ ]]
   gS                                                          [[ ------ ]]
   gT                                                          [[ ------ ]]
   gU                                                          [[ ------ ]]
   gV                                                          [[ ------ ]]
   gW                                                          [[ ------ ]]
   gX                                                          [[ ------ ]]
   gY                                                          [[ ------ ]]
   gZ                                                          [[ ------ ]]
   g!                                                          [[ ------ ]]
   g"                                                          [[ ------ ]]
   g'         like '                                           [[ ------ ]]
   g#         like #                                           [[ ------ ]]
   g*         like *                                           [[ ------ ]]
   g$         like $                                           [[ ------ ]]
   g%                                                          [[ ------ ]]
   g&         do :s on all lines                               [[ ------ ]]
   g(                                                          [[ ------ ]]
   g)                                                          [[ ------ ]]
   g{                                                          [[ ------ ]]
   g}                                                          [[ ------ ]]
   g+         go to newer state                                [[ ------ ]]
   g-         go to older state                                [[ ------ ]]
   g.                                                          [[ ------ ]]
   g,         go to newer position in change list              [[ ------ ]]
   g/                                                          [[ ------ ]]
   g?         rot13 encoding                                   [[ ------ ]]
   g:                                                          [[ ------ ]]
   g;         go to older position in chang list               [[ ------ ]]
   g<         display previous command output                  [[ ------ ]]
   g<<                                                         [[ ------ ]]
   g>                                                          [[ ------ ]]
   g>>                                                         [[ ------ ]]
   g=                                                          [[ ------ ]]
   g==                                                         [[ ------ ]]
   g@                                                          [[ ------ ]]
   g|                                                          [[ ------ ]]
   g~                                                          [[ ------ ]]
   ga                                                          [[ ------ ]]
   gb                                                          [[ ------ ]]
   gc                                                          [[ ------ ]]
   gd                                                          [[ ------ ]]
   ge         end of previous work in wrap mode                [[ ------ ]]
   gf                                                          [[ ------ ]]
   gg                                                          [[ ------ ]]
   gh         start select mode                                [[ ------ ]]
   gi                                                          [[ ------ ]]
   gj                                                          [[ ------ ]]
   gk                                                          [[ ------ ]]
   gl                                                          [[ ------ ]]
   gm                                                          [[ ------ ]]
   gn                                                          [[ ------ ]]
   go                                                          [[ ------ ]]
   gp                                                          [[ ------ ]]
   gq                                                          [[ ------ ]]
   gr                                                          [[ ------ ]]
   gs         go to sleep                                      [[ ------ ]]
   gt                                                          [[ ------ ]]
   gu                                                          [[ ------ ]]
   gv                                                          [[ ------ ]]
   gw                                                          [[ ------ ]]
   gx                                                          [[ ------ ]]
   gy                                                          [[ ------ ]]
   gz                                                          [[ ------ ]]
   g0                                                          [[ ------ ]]
   g1                                                          [[ ------ ]]
   g2                                                          [[ ------ ]]
   g3                                                          [[ ------ ]]
   g4                                                          [[ ------ ]]
   g5                                                          [[ ------ ]]
   g6                                                          [[ ------ ]]
   g7                                                          [[ ------ ]]
   g8         show hex value                                   [[ ------ ]]
   g9                                                          [[ ------ ]]


.B 'z' commands
   zC-@                                                        [[ ------ ]]
   zC-a                                                        [[ ------ ]]
   zC-b                                                        [[ ------ ]]
   zC-c                                                        [[ ------ ]]
   zC-d                                                        [[ ------ ]]
   zC-e                                                        [[ ------ ]]
   zC-f                                                        [[ ------ ]]
   zC-g                                                        [[ ------ ]]
   zC-h                                                        [[ ------ ]]
   zC-i                                                        [[ ------ ]]
   zC-j                                                        [[ ------ ]]
   zC-k                                                        [[ ------ ]]
   zC-l                                                        [[ ------ ]]
   zC-m                                                        [[ ------ ]]
   zC-n                                                        [[ ------ ]]
   zC-o                                                        [[ ------ ]]
   zC-p                                                        [[ ------ ]]
   zC-q                                                        [[ ------ ]]
   zC-r                                                        [[ ------ ]]
   zC-s                                                        [[ ------ ]]
   zC-t                                                        [[ ------ ]]
   zC-u                                                        [[ ------ ]]
   zC-v                                                        [[ ------ ]]
   zC-w                                                        [[ ------ ]]
   zC-x                                                        [[ ------ ]]
   zC-y                                                        [[ ------ ]]
   zC-z                                                        [[ ------ ]]
   zA         open a closed fold                               [[ ------ ]]
   zB                                                          [[ ------ ]]
   zC         close an open fold                               [[ ------ ]]
   zD         delete fold                                      [[ ------ ]]
   zE         eliminate all folds                              [[ ------ ]]
   zF         create a fold                                    [[ ------ ]]
   zG         mark as correctly spelled                        [[ ------ ]]
   zH         scroll half screen to right                      [[ ------ ]]
   zI         scroll half screen to left                       [[ ------ ]]
   zJ                                                          [[ ------ ]]
   zK                                                          [[ ------ ]]
   zL                                                          [[ ------ ]]
   zM         open all folds                                   [[ ------ ]]
   zN         enable folds                                     [[ ------ ]]
   zO         open folds                                       [[ ------ ]]
   zP                                                          [[ ------ ]]
   zQ                                                          [[ ------ ]]
   zR         enable folds                                     [[ ------ ]]
   zS                                                          [[ ------ ]]
   zT                                                          [[ ------ ]]
   zU                                                          [[ ------ ]]
   zV                                                          [[ ------ ]]
   zW         mark word as badly spelled                       [[ ------ ]]
   zX                                                          [[ ------ ]]
   zY                                                          [[ ------ ]]
   zZ                                                          [[ ------ ]]
   z!                                                          [[ ------ ]]
   z"                                                          [[ ------ ]]
   z'                                                          [[ ------ ]]
   z#                                                          [[ ------ ]]
   z*                                                          [[ ------ ]]
   z$                                                          [[ ------ ]]
   z%                                                          [[ ------ ]]
   z&                                                          [[ ------ ]]
   z(                                                          [[ ------ ]]
   z)                                                          [[ ------ ]]
   z{                                                          [[ ------ ]]
   z}                                                          [[ ------ ]]
   z+         scroll current line to top                       [[ ------ ]]
   z-         scroll current line to bottom                    [[ ------ ]]
   z.         scroll current line to center                    [[ ------ ]]
   z,                                                          [[ ------ ]]
   z/                                                          [[ ------ ]]
   z?                                                          [[ ------ ]]
   z:                                                          [[ ------ ]]
   z;                                                          [[ ------ ]]
   z<                                                          [[ ------ ]]
   z<<                                                         [[ ------ ]]
   z>                                                          [[ ------ ]]
   z>>                                                         [[ ------ ]]
   z=                                                          [[ ------ ]]
   z==                                                         [[ ------ ]]
   z@                                                          [[ ------ ]]
   z|                                                          [[ ------ ]]
   z~                                                          [[ ------ ]]
   za         open a fold                                      [[ ------ ]]
   zb         scroll current line to bottom                    [[ ------ ]]
   zc         close a fold                                     [[ ------ ]]
   zd         delete a fold                                    [[ ------ ]]
   ze         scroll current column to right end of screen     [[ ------ ]]
   zf         create a fold                                    [[ ------ ]]
   zg         mark word as correctly spelled                   [[ ------ ]]
   zh         scroll character to right                        [[ ------ ]]
   zi         toggle folds                                     [[ ------ ]]
   zj         start of next fold                               [[ ------ ]]
   zk         end of previous fold                             [[ ------ ]]
   zl         scroll character to left                         [[ ------ ]]
   zm         less fold levels shown                           [[ ------ ]]
   zn         reset folds                                      [[ ------ ]]
   zo         open fold                                        [[ ------ ]]
   zp                                                          [[ ------ ]]
   zq                                                          [[ ------ ]]
   zr         add one to foldlevel                             [[ ------ ]]
   zs         scroll current col to left side                  [[ ------ ]]
   zt         scroll current row to top                        [[ ------ ]]
   zu                                                          [[ ------ ]]
   zv         open folds                                       [[ ------ ]]
   zw         mark as badly spelled                            [[ ------ ]]
   zx         reapply fold level                               [[ ------ ]]
   zy                                                          [[ ------ ]]
   zz         redraw line to center                            [[ ------ ]]
   z0                                                          [[ ------ ]]
   z1                                                          [[ ------ ]]
   z2                                                          [[ ------ ]]
   z3                                                          [[ ------ ]]
   z4                                                          [[ ------ ]]
   z5                                                          [[ ------ ]]
   z6                                                          [[ ------ ]]
   z7                                                          [[ ------ ]]
   z8                                                          [[ ------ ]]
   z9                                                          [[ ------ ]]


.SH SEE ALSO
this documentation is layered to provide easier navigation.
   yVIKEYS (3), interfacing applications with yVIKEYS
   yVIKEYS (5), data file format and structure
   yVIKEYS (6), interactive system usage and navigation
   yVIKEYS (7), decision rationale, objectives, and overview
   yVIKEYS (9), user interface behavior guarantees (automation)

.SH AUTHOR
jelloshrike at gmail dot com

.SH COLOPHON
this page is part of a documentation package meant to make use of the
heatherly tools easier and faster.
