.TH vi-keys 7 2010-Jan "linux" "heatherly custom tools manual"
.na

.SH NAME
yVIKEYS \- interactive system usage and navigation

.SH DESCRIPTION (short)
yVIKEYS is a standardized, fullsome, vi/vim-like, purely keyboard-centric,
modal interface and application framework to provide wicked, powerful, and
high-end features to ALL my applications.

.SH MODES

.B definition (D).  
every system uses modes -- editing, reviewing, searching, publishing.  a mode
is simply a work context with its own specific and unique views, keys, menus,
actions, and commands.

.B complication (C).  
each application has its own modes and actions.  every simplifies for
novice users, making dumb things easy and hard things nearly impossible.
capabilities atrophy or never exist.

.B answer (A).  
standardize modes and capabilities, then build a universal, keyboard-centric
vim-like modal interface, focused on technical, power users who can stomach
a one-time, steep learning curve.

.B mode types
   -- main        broad abilities, free-flow interaction, long usage
   -- sub-mode    more specific focus, linear interaction, short usage
   -- micro-mode  tight focus, short key sequences, exit automatically

.B six main modes (MODE)
   G   god         special 3d-style omnicient pov and review
   P   progress    manage 4d timelines and action over time
   M   map         special 2d-style when content is partitioned
   S   source      normal review of content (vi/vim normal mode)
   :   command     provides a host of complex capabilities
   /   search      find and manipulate data and objects

.B sub-modes (SMOD)
   V   visual      map/object based visual selection
   \\   menu        menu system
   f   format      data presentation formatting
   o   object      object presentation formatting
   w   wander      allow pointing at object to ID them
   s   select      source/character based visual select mode
   r   replace     overwrite characters in source mode
   e   error       display and act on errors or troubles
   I   input       adding new or updating existing content
   O   omni        special 3d-style omnipotent manipulation

.B micro modes (UMOD)
   9   repeat      replay commands multiple times
   "   register    object registers to move/transfer objects
   '   mark        identify locations for return
   @   macro       keyboard macro recording and execution
   h   hint        provide automatic and manual labeling
   c   char_find   linewise searching for particular characters
   ,   buffer      select a buffer/tab/document to focus
   t   text_reg    text registers to move/transfer text


provide focused capability, more limited options, specific key sequences,
and often exit automatically when done.

.B note
   vim combines map/source as it is really a collection of lines

.SH MAJOR FUCKING DIFFERENCES
.b summary...
   -- 'd' and 'c' multikey combinations are gone

vi/vim is amazing and its hard to justify any changes to such a tried and true
system.  its worked well for generations of programmers.  how could anyone
know better or improve it without "full" knowledge.  and, then, once you have
full ability, why change it.  hahahahaha.

first, multi-key sequences can be dangerous.  they were developed to keep
screen refresh traffic down.  awesome, but this is not the most important
thing anymore.  it is hard to visualize the impact of complex 'd' or 'c'
keys, so i think it would be better to insist these complex keys go through
selection first.  it adds a key ('v'), but then you can properly see the
anticipated change.





.SH SECTIONS
   -- modal interface and modes
   -- x/horizontal movement
   -- y/vertical movement
   -- z/zoom movmement
   -- time/versioning/branching/undo/redo/play control
   -- editing/input/replace
   -- search, regex, and replace
   -- location marks
   -- hints and marking
   -- selection
   -- grouping/folding
   -- cut/paste buffers
   -- macros/scripts/repeating
   -- windows/buffers
   -- file/save/open

.SH SPECIAL CHARACTERS
.B situation (S).  
applications depend on many types of characters -- content, delimiters,
special symbols, delayed input, and controls.

.B complication (C).  
it is normally only easily input, edit, and show ascii 7bit safe, non-control
characters (32-127 range).

.B answer (A).  
i will add standard escaped characters into the yVIKEYS shared input mode so
all applications can use them.

.B adding high frequency invisible characters
   \\s     ·     visible space      (also backslash then hit space)
   \\n     ¦     delayed return     (also backslash then hit enter)
   \\e     ¥     delayed escape     (also backslash then hit escape)
   \\b     ¿     delayed backspace  (also backslash then hit backspace)
   \\d     ¾     delayed delete     (also backslash then hit delete)

.B adding file and editing control characters
   \\g     ¨     group separator for records/files
   \\f     §     field separator for records/files
   \\p     ¤     placeholder for current position during input
   \\"     ¶     delayed double quote for file/input reading
   \\\\     µ     delayed backslash for file/input reading

.B adding macro control characters
   \\,     «     wait/pause for a preset time (often 1sec)
   \\.     ª     breakpoint during execution
   \\q     ³     halt execution
   \\+     ©     update screen contents (in case of fast execution)
   \\0     £     visible null

.B adding greek characters
   type \\ first, the one of the latin characters below
   è é ê ë   ì í î ï   ð ñ ò ó   ô õ ö ÷   ø ù ú û   ü ý þ ÿ 
   A B G D   E Z H Y   I K L M   N X O P   R S T U   F C Q W

.B adding mathmatical charcters
   type \\ first, the one of the latin characters below
   å æ    Ë Ì Í    Î Æ Ç È É Ê    À Á Â Ã Ä Å   ¸ ¹ º » ¼ ½
   = ~    # a r    1 2 3 4 x y    5 6 7 8 9 z   ( ) [ ] < >

.B adding other useful characters
   type \\ first, the one of the latin characters below
   ´ ¢ ¡    Ô Ó Ö Õ    Ð Ñ Ò    ® ¯
   @ ? !    j k h l    & | ^    { }

.SH COMMAND mode
.SS ---basics---------------------------------------------------------
 :´´´¦      perform a single command
.SS ---overview-------------------------------------------------------
.B situation (S).  
rapid, simple, and frequent commands belong assigned to keystrokes.  they are
used enough to be driven into muscle memory.

.B complication (C).  
but, complicated or argument driven commands are often neglected, messy,
and/or crammed into menus and dialogs.

.B answer (A).  
i will standardize on a vim-like command line with relatively standard
commands which parallel vi/vim's version.
.SS ---full capabilities----------------------------------------------

.B invoking/exiting the mode
   :          opens the command mode at the bottom of the screen
   ¦          executes the command and returns to the prev mode
   ¥          forgets the typed text/command and returns to prev mode

.B history
   ::¦        re-run the last command executed (same as ::0¦)
   ::Ë¦       re-run the last minus count Ë command
   :¿m¢¦      mark current command as ¢ [A-Za-z]
   :¿u¢¦      unmark command presently marked as ¢
   ::¢¦       re-run the command marked as ¢
   :::        display history list, move with _KkjJ~, ¦ to edit or ¥

.B files and tabs...
   :file <name>    changes the current spreadsheet name
   :write          writes the currrent spreadsheet to file (:w)
   :quit           exit the program
   :rename <name>  changes the name of the current tab
   :resize <addr>  changes the size of a tab



.SH SEARCH mode
.SS ---basics---------------------------------------------------------
/´´´¦      perform a regular expression search of diplayed text
.SS ---overview-------------------------------------------------------
.B situation (S).  
using content/attributes to identify an entry/object or related group of them
is fundamental to almost every application.

.B complication (C).  
very few applications provide any serious search capability, especially one
that can navigate and manipulate them.

.B answer (A).  
i will standardize on a vim-like search line that uses regular expressions
and standard input and source modes.
.SS ---full capabilities----------------------------------------------

.B invoking/exiting the mode
   /          begin search mode, directly to input mode
   ¦          executes immediately, returns to the prev mode
   ¥          from search (not input), forgets search, exits

.B mode structure
   source     search acts exactly like source mode (all keys, regs)
   input      edit keys (IiAaRr) change to input, ¥ returns, ¦ runs
   history    /// exits input to source, then brings up history

.B basics
   /¦         clear the search findings
   /´´´¦      extended regex search (heatherly variant)
   /!´´´¦     literal search, no special characters
   ¥          from input mode, back to source mode

.B map-mode keys to navigate found items
   [          first entry
   <          previous entry                          [vim is n      ]
   >          next entry                              [vim is N      ]
   ]          last entry

.B history
   //¦        re-run the last search executed (same as //0¦)
   //Ë¦       re-run the last minus count Ë search
   ///        display history list, move with _KkjJ~, ¦ to edit or ¥

.B marking [searches are marked as A-Za-z]
   /¿m¢¦      mark current search as ¢
   //¢¦       re-run the search marked as ¢
   /¿u¢¦      unmark search presently marked as ¢

.B input and editing
   input is done with standard umode, including special characters
   editing is done with standard mode, including selection, buffers

.SH KEYBOARD MACROS (sub-mode)
.SS ---basics---------------------------------------------------------
 qa...q     record live keystrokes ... into macro 'a'
 @a         execute macro 'a' from current position
.SS ---overview-------------------------------------------------------
.B definition (D).  
keyboard macros repeat keystrokes as if they are being typed in realtime,
with no advanced language constructs.  they likely meet over 80% of all
automation needs with little effort.

.B value (V).  
the ability to record, edit, and repeat predictable keystroke sequences
is critical to efficiency, accuracy, and automation; and, seriously reduce
repetitive strain on the mind and body.

.B complication (C).  
very few applications provide keyboard macro capability, or, when the do, it
is unduely slow, opaque, or complex.  the value is simply not well understood
in most user bases.

.B answer (A).  
i will standardize "mostly" on vim keyboard macros but with easier editing,
simple playback, and basic debugging.  all interactive applications need
macros built early in development.
.SS ---full capabilities----------------------------------------------

.B named macros
   a-z        twenty-six (26) standard macro names
   A-Z        same twenty-six (26) macros but treated specially

.B invocation of sub-mode
   q          record a new macro in map or god mode
   @          execute an existing macro in map or god mode
   ¥          exits sub-mode early and forgets keys

.B recording new macros
   qd...q     record live keystrokes ... into macro 'd'
   qd...Q     exit recording and do not save macro
   qD...q     appending onto macro 'd' after existing contents
   qdq        erase macro 'd' (no keystrokes entered)

.B executing existing macros
   @d         execute macro 'd' at the current location
   @@         re-execute the last used macro (a-z)
   5@d        execute macro 'd' five times
   @5d        execute macro 'd' in delay mode 5
   @D         execute macro 'd' in playback/debug mode

.B defining macros at command line
   :macro h=...         directly input and save the macro
   :macro H=...         append directly to the macro
   :macro i="..."       allows ¦ (ret) and ¥ (esc)
   :macro i=\\n\\e        also allows ¦ (ret) and ¥ (esc)
   :macro j=\\"..        escaped quote can go anywhere
   :macro j= "...       leading space will allow leading "
   all leading, internal, and trailing whitespace is meaningful

.B debugging and playback controls
   .          play/pause toggle for delay mode
   +          faster execution
   -          slower execution
   ·          step forward one (space)
   ¥          terminate at current point (escape)
   ¦          run to end at full speed (return)

.B special control characters
   see SPECIAL CHARACTERS for what keys will be including in macros to
   represent control characters or can be included to help debugging.

.B gyges-specific editing existing macros
   location   in gyges, all macros are saved by name on tab Z
   editing    edit like any other cell
   saving     they automatically save with the spreadsheet
   copying    can use normal copy and saving to transfer

.B limits/warnings
   all macros must begin and end in map/god mode
   macros may not call other macros, or themselves

.SH HINTS (sub-mode)
.na
.SS ---basics-----------------------------------------------------------------
 ;;be        go to location labeled with two-letter mark "be"
.SS ---overview---------------------------------------------------------------
.B definition (D).  
hints are two-letter labels, assigned by the application, that act as a
quick mechanism to identify, access, or move to important locations, items,
or objects without a pointing device.

.B source/prototype (S).  
firefox extension called vimperator which appears to have copied from another
early firefox extention called "hit-a-hint".  the ability i love is called
extended hints.

.B value (V).   
rapid idenfification of locations is critical to idenfitying, navigating,
and accessing locations, items, or objects in an efficient, accurate, and
confident way.

.B complication (C).  
this is an uncommon feature.  most users have never had this ability and so
are are not versed in its use and would likely not understand the value.

.B answer (A).  
i will standardize "mostly" on the excellent vimperator extended hints
interface and make it absolutely universal.  this is a very, very powerful
feature if adapted everywhere.

.B top requirements to get it right
   -- very easy, quick, and simple interface
   -- large set of hints to navigate large data sets
   -- standard rule-sets for marks to make them universal

.SS ---full capabilities------------------------------------------------------
.B mark list (62 primary, plus previous and special)
   aa-aZ      general location hints
   Aa-LZ      compilier, checker, error, feedback hints
   Ma-ZZ      global search hints
   [ < > ]    first, prev, next, and last existing hint

.B invocation of sub-mode
   ;          identify a mark
   ¥          exits sub-mode early and forgets action

.B focusing on hints
   ;;be       focus on hint "be"
   ;¥  ;;¥    clear hint focus and show all hints again
   ;¦  ;;¦    show/hide hints

.B quick movements
   ;>         go to the next hint
   ;[         go to the first hint

.B extended hints actions (potential, future)
   ;s<cc>     save link destination
   ;f<cc>     focus and center
   ;e<cc>     focus and show exploded view
   ;z<cc>     focus, zoom, and center
   ;i<cc>     zoom in, and open
   ;o<cc>     zoom out, and close
   ;x<cc>     delete
   ;y<cc>     yank
   ;p<cc>     paste
   ;t<cc>     open in another tab
   ;w<cc>     open in another window

.B showing and debugging all hints
   ;?         show hint information window
   ;!         shows hints as the status line (:status hint)
   ;_         show/hide hints







.SH LOCATION MARKS (sub-mode)
.na
.SS ---basics-----------------------------------------------------------------
 ma          mark current location/object with letter 'a'
 'a          return to location/object 'a'
.SS ---overview---------------------------------------------------------------
.B definition (D).  
marks (sometimes called bookmarks) are concise, temporary references to
locations or objects which allow a user to quickly record their current
position and easily return to it later.

.B value (V).   
easily marking and returning to locations/objects is critical for efficiency,
accuracy, and confidence.  it also enables advanced editing, accurate data
movements, clever scripting.

.B complication (C).  
most users are not versed in their use, so they are underimplemented.
when built, they are typically a little cludgy, using menus or buttons; so,
the feature just attrophies over time.

.B answer (A).  
i will standardize "mostly" on the excellent vim marks interface and make
it absolutely universal.  marks are a perfect partner to hints, which i will
port from vimperator.

.B top requirements to get it right
   -- very easy, quick, and simple interface
   -- large set of marks to allow advanced actions
   -- overview, status, and highlighting to help debugging
   -- command mode interface to define and clear marks
   -- facility for interactively moving/adjusting marks
.SS ---full capabilities------------------------------------------------------
.B mark list (62 primary, plus previous and special)
   a-z        static location marks (never move)
   A-Z        moving object/content marks (move with object)          [TBD/NYI]
   0-9        script-only and programming marks (prevent collisions)  [TBD/NYI]
   '          unnamed, from where you jumped to a mark
   * ( )      visual range, top-left, bottom-right (use '* to select)       
   [ < > ]    first, prev, next, and last existing mark

.B invocation of sub-mode
   m          record a new mark in map or god mode
   '          return to an existing mark in map or god mode
   ¥          exits sub-mode early and forgets action

.B setting marks
   ma         set location of mark 'a'
   m(         set top-left corner of future visual selection
   m# '#      clear mark under cursor
   m?a        view list of all marks, then mark as 'a'

.B using marks
   'a         return to mark 'a'
   ''         return to where the last mark was called
   '[         go to first mark in [a-zA-Z]
   '?a        view list of all marks, then return to mark 'a'
   '*         enter visual mode from '( to ')

.B moving marks in wander mode
   '@         move mark under cursor
   ...        basic horizontal and vertical keys to move mark
   ¦          enter to stop editing, move mark, and exit mode

.B command line
   :mark a=0a1¦    set mark at an address
   :mark a=¦       unset a mark  (go to a ('a) and delete ('#))
   :mark clear¦    unset all lower case marks
   :mark purge¦    unset all-all marks

.B showing and debugging all marks
   m! '!      shows marks as the status line (:status mark)
   m_ '_      show/hide mark visual highlighting

.B limits/warnings
   changes to marks can not be undone (they are simple/quick)

.SH BUFFERS (AND PANELS) SUB-MODE
.SS ---basics---------------------------------------------------------
 ,a         switch to the main editing panel
 ,0         switch file labeled 0 into the current panel

.SS ---overview-------------------------------------------------------
.B definition (D).  
buffers and panels are data files/tabs and screen regions respectively.
this sub-mode allows users to move quickly to a specific screen panel and
choose the data to display/edit there.

.B value (V).   
easily, quickly, and clearly moving between views, panels, and data sets
is critical for efficiency, advanced editing, clever data manipulation,
and complex user interaction.

.B complication (C).  
most users blunder around using the mouse and then switch to the keyboard
to do real work.  switching data sets, positions, and panels requires slow
acting mouse and menu actions.

.B answer (A).  
i will standardize on my simple vim-ide keyboard interface and make it universal
to all my applications while adding a greater range of file access and more
potential panel areas.

.B top five requirements (5) to get it right
   -- must be very quick and simple to justify usage
   -- easy user interface that can be universally used
   -- must allow for a large number of data sets
   -- needs to accomodate nearly all screen interface areas
   -- automatically updating to stay current
.SS ---full capabilities------------------------------------------------------

.B invocation
   ,          enters buffer sub-mode
   ¥          exits sub-mode early and forgets action

.B standard identifiers
   0-9A-Z     thirty-six (36) standard tabs and/or buffers
   a-z        standard panel/work-area identifiers
   [ < > ]    first, prev, next, and last buffer

.B switching...
   ,a         switch to primary editing window/panel
   ,0         view the first buffer in current window/panel
   ']         switch to the last legal buffer/tab

.B information...
   ,,         for applications that can, show all buffers/files
   ,?         update and show buffer list
   ,!         buffer status line

.B standard windows/panels...
   a          main editing window
   b          secondary editing window
   c          context window to right
   d          debug window
   g          global find and search
   p          progress bar/timeline
   q          compilation and build
   t          tag window to left
   v          execution/visualization
   :          command line/window
   /          normal search line/window



.SH VISUAL ranges and saved selections (micro-mode)
.SS ---basics---------------------------------------------------------
 v          start visual selection
 ....y      change selection then perform a common action, like yank
.SS ---overview-------------------------------------------------------
.B definition (D).  
visual selection is a technique for identifying two-dimensional (xy),
contiguous ranges of objects for common treatment.

.B value (V).   
confidently and accurately doing this is critical for speed, reliability,
and efficiency, as well complex automation.

.B complication (C).  
this feature is normally very simplistic, non-standard, troublesome, and
mouse driven.  terrible for advanced users.

.B answer (A).  
standardize on the vi/vim base, generalize to handle all applications, and
make it universal across my applications.
.SS ---full capabilities------------------------------------------------------
.B initiation and termination
   v          turn on selection
   ¥ or ¦     clear selection

.B movements increase and decrease selection
   you remain in map mode, so all movement keys are still available

.B special adjustments to selection
   v          reverses the selection ends to help grow/shrink
   ex         selects full range of x
   ey         selects full range of y
   ez         selects full range of z
   e!         selects screen contents
   e*         selects all x,y,z for current workspace/tab

.B selection saving and retrieving
   there are 36 possible selections [a-z0-9]
   M¢         mark/save the current selection
   V¢         clear selection, highlight the saved selection
   0-9 are usually reserved for scripting (collision avoidance)

.B additional features
   V?¢        show all saved selections, then accept existing [a-z0-9]
   M?¢        show all saved selections, then accept new [a-z0-9] 

.B future possibilities
   -- optional short-names for saved selections
   -- removing specific cells from selections
   -- appending to existing selections
   -- discontinuous selections






.SH MAP REGISTERS (sub-mode)
.SS ---basics---------------------------------------------------------
 "ay        copy current visual selection to register 'a'
 "ap        past contents of register 'a' to current position
.SS ---overview-------------------------------------------------------
.B definition (D).  
object registers are temporary holding places for objects and their contents
in order to facilitate movement, transformation, duplication, import/export,
and scripting.

.B value (V).   
moving data between locations while editing is absolutely critical; driving
speed, accuracy, and efficiency.  it allows advanced data movements,
transformations, and advanced scripting.

.B complication (C).  
when provided, it is usually a single, shared, generic desktop clipboard for
cut, copy, and paste. fitting most users.  this neglects all advanced uses
and automation.

.B answer (A).  
i will standardize "mostly" on the excellent vim register standard, and
make it absolutely universal while adding flexible import/export and sepated
text registers.

.B top five requirements (5) to get it right
   -- must be very quick and simple to justify usage
   -- easy user interface that can be universally used
   -- must allow for multiple registers to be flexible
   -- accomodate import and export of data
   -- standard/compatible with text registers in source mode
.SS ---full capabilities------------------------------------------------------
.B invoking object register sub-mode
   "          called from map or visual mode
   ¥          return to previous mode

.B object register list (39)
   /*---(named)-----------------------*/
   a-z        named registers, always overwrites existing data
   A-Z        named registers, appends to existing data (not implemented)
   /*---(special)---------------------*/
   <none>     current selection or location
   $          all content on current tab
   "          unnamed, default register
   +          import from vi/vim clipboard  (~/z_gehye/vi_clip.txt)
   -          export to vi/vim clipboard    (~/z_gehye/vi_clip.txt)
   >          read from shared desktop clipboard (NOT IMPLEMENTED)
   <          send to shared desktop clipboard (NOT IMPLEMENTED)

.B identify register for action
   "a         select register 'a' (single action)
   "A         select register 'a' (single action), but in append mode
   "-         select the vi/vim sharing file

.B most basic register actions (work without register reference)
   y          yank/copy  to register
   d          delete/cut to register
   x          clear/copy to register
   p          paste after current position
   P          paste before current position


   a A        append after
   i I        insert before  ("ai inserts register before)
   o O        over/under
   y Y        yank/copy to selected register, cursor stays at end
   d D        delete/cut to selected register, cursor stays at beg
   x X        clear content without making a copy
   r R        replace content (char-by-char)
   s S        substitute content (delete then insert)
   p P        paste content from selected register after cursor

.B multiple paste
   if a cell of data is in register and an area is selected
   if a column of data is in register and a single row is selected
   if a row of data is in register and a single column is selected

.B pulling data from registers (TEXT/SOURCE MODE)
   p  (m)     paste content from selected register over current position

.B maintaining registers
   #          clear selected register, no effect on other data
   *          clear all registers
   g          reselect register area (go)

.B showing and debugging all registers
   "!         shows current register on the status line
   "?         shows a list of all the registers with critical info

.B +/- regs, reading or writing data to vi_clip.txt
   ---examples---------------------
   "-v        writes   format 'v' from selected area
   "c-t       writes   format 't' from register 'c'
   "+v        reads in format 'v' starting at current location
   "f+c       reads in format 'c' into register 'f'
   ---visual-----------------------
   v s        pure-columnar  , printables , untrimmed , with empties
   V S        pure-columnar  , printables , untrimmed , with empties
   ---sources----------------------
   s          separate lines , sources    , trimmed   , no empties
   S          separate lines , (prepended addresses)
   f          file format    , address and source only
   F          file format    , complete
   ---exchange---------------------
   c          standard-csv   , printables , trimmed   , with empties
   C          standard-csv   , sources    , trimmed   , with empties
   t          tab-delimited  , printables , trimmed   , with empties
   T          tab-delimited  , sources    , trimmed   , with empties
   r          ascii-records  , printables , untrimmed , with empties
   R          ascii-records  , sources    , untrimmed , with empties
   ---other------------------------
   p          post-script

.B + regs, reading vi_clip.txt
   v          pure-columnar  , printables only, no adjust
   s          space-delimited, sources or printables, no adjust
   c          standard-csv   , sources or printables, no adjust
   t          tab-delimited  , sources or printables, no adjust
   r          ascii-records  , sources or printables, no adjust
   V          same as v only column widths adjust (sizer only)
   S C T R    same as s, c, t, r only column widths adjust/sizer



.B who knows ???
   d          delete                 CELL_erase ()
   x          cut to register        REG_cut    ()
   y          copy to register       REG_copy   ()
   p          paste from register    REG_paste  ()
   Y                                 REG_valuesout ()

.B actions on data (1 or 3 chars)
   ["x]d      delete/cut from content and overwrite register <x>
   ["x]D      delete/cut as displayed and overwrite register <x>
   ["x]y      yank/copy from content and overwrite register <x>
   ["x]Y      yank/copy as displayed and overwrite register <x>
   ["x]p      paste (into empty space) from register <x> back into the data
   ["x]r      replace (over existing) from register <x> back into the data
   ["x]i      insert before (push left) from register <x> back into the data
   ["x]a      insert after (push right) from register <x> back into the data
   ["x]O      insert above (push up) from register <x> back into the data
   ["x]o      insert below (push down) from register <x> back into the data
   ["x]?      display contents of register <x> on command line

.B actions on registers only
   "x2y       copy from register <x> into register <y>
   "-2x       delete contents of register <x>
   "#         save registers to a file







.B unimplemented vim features
   :reg       to list registers (included in "?)


   -- delete/clear a register
   -- append one register to another
   -- list registers with contents
   -- load a register from an outside file
   -- save a register outside to a file



   v          visual selection
   V          visual cummulative selection
   gv         go to previous selection
   y          yank (fresh)
   Y          yank (append)
   p          paste (into open area)
   P          paste over
   x          cut for later integration
   X          cut and leave absolute connections
   d          delete and do no copy into register
   #a         delete contents of a register
   )a         copy the current register into the new one
   >a         move the current register into the new one
   ]a         append the current register to the new one





.B scripting language.  
interpretive programming languages that act as rapid development environments
to glue programs together.  examples include, bourne-shell, awk, perl, python,
java, etc.

.B extension languages.  
interpretive programming mini-languages that allow the capabilities of
a program to be extended beyond its original purpose.  expamples include,
guile, lua, scheme, lisp, etc.

.B macro language.  
interpretive programming that can access all user capabilitys and exposes
more complicated features to allow automation.  examples include, vim scripts,
lotus 123 macros, etc.


.SH PROGRESS MODE
.B situation.  
some applications provide the ability to view actions and output over time,
i.e., the fourth dimension, including, video, audio, visualization, and
simulation.

.B complication.  
applications that provide progress, time, or sequences typically use timelines,
but actions on timelines tend to be highly varied, simplistic, and mouse-based.
the result is that these interfaces tend to keep things too simple and weak.

.B answer.  
i will add a new mode specifically for progress/timeline viewing and
manipulation.  it will built on the base of vi-keys normal/map mode movements
and add many advanced vi/vim functions.

.B overview.  
progress mode will be based on a timeline, have extended play controls, and
all complex interactions, marking, selection, registers, and other abilities.
this ability is critical and will be treated as such.

.B invoking progress mode
   ,p         enter progress bar mode where it shows in addition to others
   ,P         enter full progress mode for sequencing multiple timelines
   ,,         back to main mode

.B horizontal movement
   0          beginning
   H          left/back five
   h          left/back
   <bs>       pause, and step frame or tiny bit backward
   <sp>       pause, and step frame or tiny bit forward
   l          right/fore
   L          right/fore five
   $          ending

.B vertical movement (between timelines)
   _          top-most
   K          up five
   k          up
   j          down
   J          down five
   ~          bottom-most (same symbol as null lines at bottom of vim

.B scale controls
   i          zoom-in
   o          zoom-out

.B play and speed controls
   +          faster
   .          play/pause
   -          slower

.B current bar alignment (uses the standard shcle codes)
   ^          prefix control code for alignment
   ^0         edge   (0.00)  extreme and unlikely
   ^s         start  (0.05)
   ^h         left   (0.28)
   ^c         center (0.50)
   ^l         rignt  (0.72)
   ^e         end    (0.95)
   ^$         edge   (1.00)  extreme and unlikely
   -- ^ was vim for first character on the line (under utilized)

.B special controls
   #          write diagnostic information

.B TBC (to be created)
   marks using m and '
   visual selections
   registers for cut, copy, paste
   ecgz commands for horizontal movement
   move to a specific time
   commands to set progress bar to stay at five positions (shcle)
   command to heighten and shorten progress window when multiple lines used
   grouping and ungrouping to make "blocks" of content









.SH GOD MODE
.B situation.  
some applications provide the ability to view and/or manipulate in three or
four (time) dimensions, e.g., modeling and robotics.  the faster and cleaner
the better so that this three-dimensional ability becomes useful.

.B complication.  
all applications using four-dimensions use different interfaces and shortcuts.
each one provides completely different capabilities.  and, they are all
hampered by trying to keep it very simple.


.B answer.  
add a new mode specifically for four-dimensional viewing and manipulation.
build it on the base of vi-keys normal/map mode movements, but clear out the
other keys to make room for complex interactions.

.B linear movements
   0HhlL$

.B source mode 1D vertical movements
   _          beginning of entry
   K          up 5 lines
   k          up 1 line
   j          right 1 line
   J          right 5 lines
   ~          bottom-most (same symbol as null lines at bottom of vim













.SH UNIVERSAL

   :          command mode
   <esc>      normal mode
   v          visual mode
   "          registers           (existing)
   m '        marks               (existing)
   q @        macros and scripts  (existing)
   M ;        hints               (new)
   c          <control>           (new)
   \          <alt> or <menu>     (new)
   /          search              (existing)
   f          close search
   *          search for current  (existing)
   nN         continue search     (existing)
   !          filter
   %          matching
   uU         undo
   pP         paste
   y          yank
   dD         delete
   xX         delete
   aA         append/add
   iI         insert
   rR         replace


.SH UNIVERSAL NEW ONES
   ,          windows/tabs
   t          tags
   ?          definition/prototype/etc
   F          data formatting (very, very useful)
   +          enter positive numerical data
   -          enter negative numerical data
   =          enter a formula
   #          enter note, comment, or string formula
   s          quick data input








registers provide a temporary holding place for data in order to facilitate
movement between different locations in the larger data set or between
applications.  when provided, most applications allow access to the single
desttop clipboard for cut, copy, and paste.  this fits the requirements of
a vast majority of all users.

.B situation (S)

.SH DATA FORMATTING (sub-mode)

the purpose of data formatting, including, fonts, alignment, numerical
formats, etc., is to allow users to easily and quickly consume data in order
to discover useful insights, concepts, and conclusions.

.B situation (S)
most allications fall in the range of having a narrow, specific data set and
fixed formatting; or they providing a range of custom formatting options to
help user with complex situations.

.B complication (C)
often, formatting is viewed as the critical element rather than the icing on
the top of great analysis and insight.  formatting often means superfluous
presentation elements like fonts types, sizes, and colors.

.B question (Q)
how to standardize usage of both data and analysis focused formatting that
can be learned once and added easily to any application ?

.B answer (A)
easy, take lessions from old-school terminal and text-based analytical tools
like lotus 123 and visicalc to develop a new standard.

.B allowed from which modes...
   map        on a single cell
   visual     on a range of cells

.B invoking data formatting
   F          format sub-mode
   f          format sub-mode for a single action
   <es>       return to normal mode

.B horizontal alignment
   <          left
   [          left with brackets []
   {          left, indented, with brackets []
   >          right
   ]          right with brackets []
   }          right, indented, with brackets []
   |          center
   ^          center with brackets []

.B numeric
   /*---(normal)-----------------------*/
   i          integer
   r          real/float
   ,          commas in thousands, millions
   s          commas and sign
   a          accounting (commas and parens for negative)
   $          currency (commas and currency sign)
   p          percentage (shows a tailing 'p' as '%' is problematic
   /*---(technical)--------------------*/
   e          exponential (E means with spaces)
   #          technical (commas, decimal commas, signs)
   x          hexadecimal (X means with separators every byte)
   b          binary (B means with separators every four bits)
   o          octal (O means with separators every byte)
   /*---(time)-------------------------*/
   t          time
   d          date
   T          timestamp
   D          time and date
   /*---(other)------------------------*/
   P          point/bullet

.B decimals
   0-9        number of decimals shown

.B filler for strings
   <sp>       space filled (default)
   -          dashes
   =          equals
   _          underscores
   .          periods
   +          pluses

.B used letters
    + ++         ++   +   +   ++++++++++ ++    + ++  +
   ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 ,.:;!?_ +-*/= cr bs  50
   abcdefghijklmnopqrstuvwxyz &#|@ ~^$% '`" (){}[]<> sp es \\  49
   ++ ++   +     ++ +++   +    ++   ++        ++++++ +  

.B used letters
   ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 ,.:;!?_ +-*/= cr bs  50
   abcdefghijklmnopqrstuvwxyz &#|@ ~^$% '`" (){}[]<> sp es \\  49

.SH OBJECT SIZING

.B invoking object sizing
   S          sizing mode
   <cr>       return to normal mode

.B widths
   L          smaller by five
   l          smaller by one
   h          bigger by one
   H          bigger by five

.B heights
   J          smaller by five
   j          smaller by one
   h          bigger by one
   H          bigger by five

.B merging (not grouping)
   M


   /*---(fixed)------------------------*/
   m          minimal
   n          normal
   N          normal+
   w          wide
   W          very wide
   /*---(adjustments)------------------*/

.SH TEXT REGISTERS (sub-mode TEXTREG)
.B situation.  
begin able to copy and move text between locations in an application while
editing is critical to increasing speed, accuracy, and reducing mistakes.
it allows the editor to perform advanced data movements and transformations;
and it is fundamental to any advanced scripting.

.B complication.  
when provided, most applications allow access to the single, shared, generic
desktop clipboard for cut, copy, and paste.  this fits the requirements of
a vast majority of users.  but, as a result powerful data editing requires
cludgy supplemental tools or work-arounds just to store data.

.B answer.  
we will standardize around a keyboard-centric, simplified, vim-like model with
multiple standard registers.  this mode is called TEXTREG.

.B overview.  
text registers are temporary holding places for textual data which facilitate
movement between different storage locations.

.B register list (55)
   "          unnamed, default register
   a-z        named registers, always overwrites existing data
   A-Z        named registers, appends to existing data
   -          my vi/vim clipboard (/tmp/vi_clip.txt)
   +          shared desktop clipboard (NOT IMPLEMENTED)
   :          last command executed
   /          last search executed
   %          full qualified, absolute file name

.B available from which modes
   SOURCE     source mode allows text registers at any time
   SELECT     select sub-mode allows registers on selected text

.B primary key involved
   "          identify the register for target/source

.B identify register for action
   "a         select register 'a' (single action)
   "A         select register 'a' (single action), but in append mode
   "-         select the vi/vim sharing file

.B pushing data into registers
   y          yank/copy  content to selected register
   d          delete/cut content to selected register
   x          clear/copy content to selected register
   p          paste register content after cursor
   P          paste register content before cursor

.B pulling data from registers (TEXT/SOURCE MODE)
   p          paste register content after cursor
   P          paste register content before cursor
   r, R       replace text with register content starting at cursor

.B maintaining registers
   #          clear selected register, no effect on other data
   *          clear all registers
   g          goto beginning register position in source
   G          goto ending register position in source

.B debugging and observing
   !          shows selected register on the status line

.B showing register overview
   "?         shows a list of all the registers with critical info







.SH TEXT REPLACEMENT/OVERTYPE (sub-mode REPLACE)

.B situation.  
often creators and editors require quick, selective replacement of text
in-place or overtyping.  this is a frequent activity and allows much more
surgical, accurate, and quick updates.

.B complication.  
most applications just don't provide this.  they require text to be deleted
and new text re-added.  this causes many issues, including, changing too many
characters, altering line lengths, and requiring great short-term memory ;)

.B answer.  
we will standardize around the vi/vim replace mode.  done.

.B overview.  
text replacement is called from source mode and has two flavors -- single and
contiguous character overtype.

.B special look or formatting
   1) special placeholder character will show current insertion point
   2) editing area will have a unique color indicating replace mode
   3) message line will display mode and helpful hints

.B single character changes
   r<c>       replace char under the cursor with <c>
   r<es>      abort change early without change
   r<cr>      abort change early without change

.B contiguous character changes
   R          switches to replace sub-mode
   <c>        replace char under cursor with <c>, and move cursor right
   <bs>       backspace puts the character back and moves left
   <es>       escape accepts change and exits replace mode
   <cr>       return accepts change and exits replace mode

.B notes.  
   1) all control characters (0 - 31, 127) are filtered out
   2) contiguous mode will go beyond end-of-line with no issues


.SH HORIZONTAL


.SH SOURCE MODE (SELECT, REPLACE, and INPUT)
.B situation.  
the ability to create, review, and change lines of text is fundamental to all
important applications.  the focus must be on speed, accuracy, and efficiency
since it happens with such frequency.

.B complication.  
modern applications are typically optimized for review, not creation.
editing is non-standard, requiring mice to position the cursor, keyboards to
make changes, and buttons to select fields.

.B answer.  
we will standardize around a modal, keyboard-centric, simplified, vim-like
model which allows the user to edit quickly and easily.

.B overview.  
source mode allows the user to review, move, and delete text; input mode allows
them to add new text, and replace mode allows them to overtype exising text.

.B source mode horizontal movements
   0 HhlL $      horizontal
   g SHshcleLE   goto horizontal
   z shcle       scroll horizontal
   ^ shcle       scroll lock


.SH SOURCE mode

.B standard horizontal movements
   0HhlL$        move and adjust screen as required
   g + shcle     goto a point in the available display space
   z + shcle     scroll current position to a point in display space
   g + SHLE      0.5 and 1.0 page moves left and right
   wWeEbB        word based movements
   Æ|            specific character position

.B undo and redo (separate from map mode undo/redo)
   u             undo last update
   U             redo last update

.B character searches
   f¢            search forward for character ¢
   F¢            search backward for character ¢
   n             next match forward
   N             next match backward
   #             search forward for current character
   found character is saved between searches for quick reuse

.B delete, clear, and change
   Å             deletes the previous character
   Ä             deletes the current character
   d + hlwbe0$   delete a character(s) in the given direction
   x + hlwbe0$   clear a character(s) in the given direction
   c + hlwbe0$   delete a character(s) then enter input micro-mode
   D             shortcut for dl
   X             shortcut for xl

.B inputing new text (INPUT micro-mode)
   i             insert before current character
   a             append after current character
   I             insert at end-of-line
   A             append to beginning-of-line

.B replacing existing text (REPLACE micro-mode)
   r             replace current position (exits automatically)
   R             replace a string of characters until exiting

.B repeats and counts
   Æ             all commands can take a prefixed count

.SH INPUT micro-mode
.SS ---basics---------------------------------------------------------
 i...¥     insert text before the current character
.SS ---overview-------------------------------------------------------
.B purpose.  
fast, unincumbered, free-form, thought-free typing is critical to any text
entry/creation task.

.B complication.  
many applications attempt to mix creation, editing, and formatting all in a
single editing context.

.B answer.  
standardize on a simplified vim-modal interface that separates input from
editing and review for speed.

.B NOTE.  
all text entry uses this input micro-mode, it is universal.
.SS ---full capabilities----------------------------------------------

.B invoking input mode from source mode
   i          insert before current character
   a          append after current character
   I          insert at end-of-line
   A          append to beginning-of-line

.B placeholder display
   ¤          placeholder where next character will go
   this character is temporary and will not be saved

.B control characters
   ¥          return to source mode for further editing
   ¦          accept all changes and exit source mode also
   ¿          delete the character before the current one
   ¾          delete the current character
   \\          allows entry of special characters (see below)

.B adding special characters and controls (see SPECIAL CHARACTERS)

.B insert specification
   -- moves current char (and rest) one to the left, adding to the length
   -- current chacrcter made into a ¤
   -- each new character current location and ¤ shifted right
   -- ¦ and ¥ both remove ¤ and collapse its location
   -- ¦ saves all changes, executes if needed, and returns to map mode
   -- ¥ saves all changes, returns to source mode, current is last char added


.SH REPLACE micro-mode
.SS ---basics---------------------------------------------------------
 r½      replace the current character in source mode
.SS ---overview-------------------------------------------------------
.B purpose.  
to speed text editing, replace provides a very rapid type-over of existing
characters to fix small typing mistakes.

.B complication.  
many applications require two steps, first delete or highlight the mistake,
then type the new text.

.B answer.  
standardize on a simplified vim-modal interface that includes this rapid
short-hand for type-over.

.B NOTE.  
all text includes uses this replace micro-mode, it is universal.
.SS ---full capabilities----------------------------------------------

.B invoking input mode from source mode
   r          replace current position (exits automatically)
   R          replace a string of characters until exiting

.B placeholder display
   ¤          placeholder shows what position will be replaced
   this character is temporary and will not be saved

.B control characters
   ¥          return to source mode for further editing
   ¦          all accept changes and exit source mode also
   Å          move one character left  (leave character)
   Ä          move one character right (leave character)
   \\          allows entry of special characters (same as input)

.B single replace
   r½
   Ær½
   R½½½¥

.SH ENDS and EDGES
.B situation (S).  
the ability to navigate quickly from one break or discontinuity to the
next allows creators and editors to quickly explore, identify, and manage
transitions.

.B complication (C).  
this is a consistently neglected feature in applications.  usually, a user
must manually step through content, or, rely on an pre-existing index or
table of contents.

.B answer (A).  
vim has a inherently one-dimensional view of the world ;) but, we can make
it a great foundation for a three-dimensional end and edge finding system when
combined with lotus 123 end finding.

.B overview (O).  
end and edge movements allow the creator and editor to quickly explore their
full environment and move to critical breaks and transition points without
prior knowledge of their locations.

.B primary modifier key
   e          end/edge

.B standard, universal movement suffix keys
   shcle x    horizontal (x)
   tkmjb y    vertical (y)
   nopif z    depth (z)
   azud       corners
   gqrv       unused
   *          all on tab/area
   !          all on screen

.B horizontal (x-axis)...    e + [SsHhCcLlEe]
   eS         edge/leftmost start of all allowed space
   eH         edge/maximum leftmost edge of any row/line
   es         edge/maximum leftmost edge in this row/line
   eh         next normal break to the left
   ec         horizontal center of current block
   eC         horizontal center of all used space
   el         next normal break to the right
   ee         edge/maximum rightmost edge in this row/line
   eL         edge/maximum rightmost edge of any row/line
   eE         edge/rightmost end of all allowed space

.B vertical (y-axis)...      e + [TtKkMmJjBb]
   eT         edge/topmost start of all allowed space
   eK         edge/maximum topmost edge of any col/line
   et         edge/maximum topmost edge in this col/line
   ek         next normal break to the top
   em         vertical center of current block
   eM         vertical center of all used space
   ej         next normal break to the bottom
   eb         edge/maximum bottommost edge in this col/line
   eJ         edge/maximum bottommost edge of any col/line
   eB         edge/bottommost end of all allowed space

.B depth (z-axis)...         e + [NnOopPiIfF]
   eN         edge/nearest start of all allowed space
   eO         edge/maximum nearest edge of any col/line
   en         edge/maximum nearest edge in this col/line
   eo         next normal break to the nearside
   ep         depth center of current block
   eP         depth center of all used space
   ei         next normal break to the farside
   ef         edge/maximum farthest edge in this col/line
   eI         edge/maximum farthest edge of any col/line
   eF         edge/farthest end of all allowed space

.B center of contiguous space
   eC         horizontal center of all available space
   ec         horizontal center of used space
   eM         vertical center of all available space
   em         vertical center of used space
   eP         depth center of all available space
   ep         depth center of used space

.B 2d corners...             e + [aAuUzZdD]
   eA         top-left edge of all available space
   ea         top-left edge of all used space
   eU         top-right edge of all available space
   eu         top-right edge of all used space
   eZ         bottom-right edge of all available space
   ez         bottom-right edge of all used space
   eD         bottom-left edge of all available space
   ed         bottom-left edge of all used space

.B within one-dimensional source mode
   w, W       next word
   b, B       beginning of word
   e, E       end of word

.B within video or audio type streams
   <          left any break                                   [[ ------ ]]
   >          right any break                                  [[ ------ ]]
   (          left small break                                 [[ ------ ]]
   )          right small break                                [[ ------ ]]
   {          left big break                                   [[ ------ ]]
   }          right big break                                  [[ ------ ]]

.SH GOTO and SCROLL
.B situation.  
jumping quickly between areas of the screen is critical for rapid creation
and editing.  additionally, scrolling or sliding the screen content, instead
of just moving, helps maintain context while jumping.

.B complication.  
modern applications rely on hard to reach arrow and page keys, as well as
mouse movement to alter screen position.  any of these methods slows the
editor down considerably and requires a context shift.

.B answer.  
we will take the vi/vim movements for both jumping and scrolling, but apply
a more consistent key assignment as vim uses a very inconsistent combination
of keystrokes.

.B primary modifier keys
   g          goto                                              [[ prefix ]]
   z          scroll                                            [[ prefix ]]

.B standard, universal movement keys
   hlkjoi     six directions along three axis
   setbnf     start, end, top, bottom, near, far
   azud       alpha, omega, upper-right, down-left
   cm.+       center, middle, front-back, full center
   w          wordish

.B horizontal movement/scrolling
   gS         go a full screen/page to the left
   gH         go a half screen/page to the left
   gs (zs)    go (scroll current) left end of screen            [[ sleep  ]]
   gh (zh)    go (scroll current) left quarter of screen        [[ select ]]
   gc (zc)    go (scroll current) center of screen              [[        ]]
   gl (zl)    go (scroll current) right quarter of screen       [[        ]]
   ge (ze)    go (scroll current) right end of screen           [[ word   ]]
   gL         go a half screen/page to the right
   gE         go a full screen/page to the right

.B vertical movement/scrolling
   gT         go a full screen/page upwards
   gK         go a half screen/page upwards
   gt (zt)    go (scroll current) top end of screen             [[ n.tab  ]]
   gk (zk)    go (scroll current) top quarter of screen         [[ wrap.k ]]
   gm (zm)    go (scroll current) middle of screen              [[ middle ]]
   gj (zj)    go (scroll current) bottom quarter of screen      [[ wrap.j ]]
   gb (zb)    go (scroll current) bottom end of screen          [[        ]]
   gJ         go a half screen/page downwards
   gB         go a full screen/page downwards

.B corner movement/scrolling
   ga (za)    go (scroll current) top-left corner (alpha)       [[ ascii  ]]
   gu (zu)    go (scroll current) top-right corner (near)       [[ next   ]]
   gz (zz)    go (scroll current) bottom-right corner (omega)   [[ byte   ]]
   gd (zd)    go (scroll current) bottom-left corner (far)      [[ file   ]]
   g. (z.)    go (scroll current) center of screen              [[        ]]
   gA (zA)    go half page up and left    (gK + gH)             [[        ]]
   gU (zU)    go half page up and right   (gK + gL)             [[        ]]
   gZ (zZ)    go half page down and right (gJ + gL)             [[        ]]
   gD (zD)    go half page down and left  (gJ + gH)             [[        ]]

.B vi/vim key collisions -- NONE of any importance


.SH HORIZONTAL MOVEMENT (x-axis)

horizontal/x-axis movement is fundamental to almost every visual application,
including textual user interfaces (like vim) and graphical user interfaces,
as well as command-line editing and many others.

.B primary keys involved
   h l         left and right
   (cegz) s e  start and end, only for use with cegz prefixes

primary keys are 'h' (left) and 'l' (right).  suffix keys are 'e' (start)
and 'e' (end).  rotation keys are 'y' (yaw) and 't' (turn).

.B simple movement, move cursor, but not screen
   0          beginning of line/bounded space                  [[ ------ ]]
   H          left 5 char/units                                [[ yes    ]]
   h          left 1 char/units                                [[ ------ ]]
   l          right 1 char/units                               [[ ------ ]]
   L          right 5 char/units                               [[ yes    ]]
   $          ending of line/bounded space                     [[ ------ ]]

.B move screen and cursor
   cs         left a page                                      [[ good   ]]
   ch         left a half page                                 [[ good   ]]
   cl         right a half page                                [[ !!!!!! ]]
   ce         right a full page                                [[ good   ]]

.B move cursor to a part of the screen (no screen movement)
   gs         left edge of screen                              [[ good   ]]
   gh         left quarter of screen                           [[ good   ]]
   gc         center of screen                                 [[ good   ]]
   gl         right quarter of screen                          [[ good   ]]
   ge         right edge of screen                             [[ good   ]]

.B scroll cursor position to a new screen position (no cursor movement)
   zs         left edge of screen                              [[ good   ]]
   zh         left quarter of screen                           [[ good   ]]
   zc         center of screen                                 [[ good   ]]
   zl         right quarter of screen                          [[ good   ]]
   ze         right edge of screen                             [[ good   ]]

.B contiguous area movement (all start with 'e')
   es         left edge of all used space                      [[ ------ ]]
   eH         left edge of close objects/line-of-sight         [[ ------ ]]
   eh         left edge of contiguous area                     [[ ------ ]]
   ec         middle of contiguous area                        [[ ------ ]]
   el         right edge of contiguous area                    [[ ------ ]]
   eL         right edge of close objects/line-of-sight        [[ ------ ]]
   ee         right edge of all used space                     [[ ------ ]]

.B rotations around the y-axis (yaw)
   cv         yaw (veer) leftward 45 deg                       [[ ------ ]]
   V          yaw (veer) leftward 5 deg                        [[ ------ ]]
   v          yaw (veer) leftward 1 deg                        [[ ------ ]]
   y          yaw rightward 1 deg                              [[ ------ ]]
   Y          yaw rightward 5 deg                              [[ ------ ]]
   cy         yaw rightward 45 deg                             [[ ------ ]]

.SH VERTICAL MOVEMENT (y-axis)

vertical/y-axis movement is fundamental to almost every visual application,
including textual user interfaces (like vim) and graphical user interfaces,
as well as command-line editing and many others.

primary keys are 'j' (down) and 'k' (up).  suffix keys are 't' (top)
and 'b' (bottom).  rotation keys are 'u' (up) and 'd' (down).

.B simple movement, move cursor, but not screen
   _          beginning of line/bounded space                  [[ good   ]]
   K          up 5 char/units                                  [[ !!!!!! ]]
   k          up 1 char/units                                  [[ ------ ]]
   j          down 1 char/units                                [[ ------ ]]
   J          down 5 char/units                                [[ !!!!!! ]]
   ~          ending of line/bounded space                     [[ good   ]]

.B move screen and cursor
   ct         up a page                                        [[ good   ]]
   ck         up a half page                                   [[ good   ]]
   cj         down a half page                                 [[ good   ]]
   cb         down a full page                                 [[ good   ]]

.B move cursor to a part of the screen (no screen movement)
   gt         top edge of screen                               [[ yes    ]]
   gk         top quarter of screen                            [[ good   ]]
   g.         middle of screen                                 [[ good   ]]
   gj         bottom quarter of screen                         [[ good   ]]
   gb         bottom edge of screen                            [[ good   ]]

.B scroll cursor position to a new screen position (no cursor movement)
   zt         top edge of screen                               [[ ------ ]]
   zk         top quarter of screen                            [[ good   ]]
   z.         middle of screen                                 [[ ------ ]]
   zj         bottom quarter of screen                         [[ good   ]]
   zb         bottom edge of screen                            [[ ------ ]]

.B contiguous area movement (all start with 'e')
   e_         top edge of all used space                       [[ ------ ]]
   et         top edge of close objects/line-of-sight          [[ ------ ]]
   ek         top edge of contiguous area                      [[ ------ ]]
   e.         middle of contiguous area                        [[ ------ ]]
   ej         bottom edge of contiguous area                   [[ ------ ]]
   eb         bottom edge of close objects/line-of-sight       [[ ------ ]]
   eg         bottom edge of all used space                    [[ ------ ]]

.B rotations about the x-axis (pitch)
   ca         pitch (ascend) upward 45 deg                     [[ ------ ]]
   A          pitch (ascend) upward 5 deg                      [[ ------ ]]
   a          pitch (ascend) upward 1 deg                      [[ ------ ]]
   p          pitch (plunge) downward 1 deg                    [[ ------ ]]
   P          pitch (plunge) downward 5 deg                    [[ ------ ]]
   cP         pitch (plunge) downward 45 deg                   [[ ------ ]]

.SH ZOOMING MOVEMENT (z-axis)

zooming/z-axis movement is fundamental to almost every visual application,
including textual user interfaces (like vim) and graphical user interfaces,
as well as command-line editing and many others.

.B primary keys involved
   i o        inward (pushing in) and outward (pulling out)
   c e g z    standard prefix keys
   n f        near and far, suffix keys for cegz
   r s        rotate right and spin left around z-axis

primary keys are 'i' (in) and 'o' (out).  suffix keys are 'z' (zoom)
and 'a' (away).  rotation keys are 'r' (rotate) and 's' (spin).

.B simple movement, move cursor, but not screen
   g+         beginning of line/bounded space                  [[ ------ ]]
   I          in 5 char/units                                  [[ ------ ]]
   i          in 1 char/units                                  [[ ------ ]]
   o          out 1 char/units                                 [[ ------ ]]
   O          out 5 char/units                                 [[ ------ ]]
   g-         ending of line/bounded space                     [[ ------ ]]

.B move screen and cursor
   cz         in a page                                        [[ ------ ]]
   ci         in a half page                                   [[ ------ ]]
   ci         out a half page                                  [[ ------ ]]
   ca         out a full page                                  [[ ------ ]]

.B move cursor to a part of the screen (no screen movement)
   gz         top edge of screen                               [[ ------ ]]
   gi         top quarter of screen                            [[ ------ ]]
   g#         middle of screen                                 [[ ------ ]]
   go         bottom quarter of screen                         [[ ------ ]]
   ga         bottom edge of screen                            [[ ------ ]]

.B scroll cursor position to a new screen position (no cursor movement)
   zz         top edge of screen                               [[ ------ ]]
   zi         top quarter of screen                            [[ ------ ]]
   z#         middle of screen                                 [[ ------ ]]
   zo         bottom quarter of screen                         [[ ------ ]]
   za         bottom edge of screen                            [[ ------ ]]

.B contiguous area movement (all start with 'e')
   e+         front edge of all used space                     [[ ------ ]]
   ez         front edge of close objects/line-of-sight        [[ ------ ]]
   ek         front edge of contiguous area                    [[ ------ ]]
   e#         middle of contiguous area                        [[ ------ ]]
   eo         after edge of contiguous area                    [[ ------ ]]
   ea         after edge of close objects/line-of-sight        [[ ------ ]]
   e-         after edge of all used space                     [[ ------ ]]

.B rotations about the z-axis (roll)
   cw         roll (wind) counter-clockwise 45 deg             [[ ------ ]]
   W          roll (wind) counter-clockwise 5 deg              [[ ------ ]]
   w          roll (wind) counter-clockwise 1 deg              [[ ------ ]]
   r          roll clockwise 1 deg                             [[ ------ ]]
   R          roll clockwise 5 deg                             [[ ------ ]]
   cr         roll clockwise 45 deg                            [[ ------ ]]

.SH ORIGINAL MAPPINGS

.B normal mode
   C-@        - - - - - - -                                    [[ ------ ]]
   C-a        add <n> to number at/after cursor                [[ ------ ]]
   C-b        scroll <n> screens backward                      [[ ------ ]]
   C-c        interupt current command/search                  [[ useful ]]
   C-d        scroll <n> lines down                            [[ ------ ]]
   C-e        scroll <n> lines upward                          [[ ------ ]]
   C-f        scroll <n> screens forward                       [[ ------ ]]
   C-g        display current filename and position            [[ maybe  ]]
   C-h        dup with 'h'                                     [[ ------ ]]
   C-i        dup with <tab>                                   [[ ------ ]]
   C-j        dup with 'j'                                     [[ ------ ]]
   C-k        - - - - - - -                                    [[ ------ ]]
   C-l        redraw screen                                    [[ useful ]]
   C-m        dup with <cr>                                    [[ ------ ]]
   C-n        dup with 'j'                                     [[ ------ ]]
   C-o        older entry on jump list                         [[ ------ ]]
   C-p        dup with 'k'                                     [[ ------ ]]
   C-q        terminal flow control                            [[ ------ ]]
   C-r        redo changes undone with undo                    [[ useful ]]
   C-s        terminal flow control                            [[ ------ ]]
   C-t        jump to <n> older tag                            [[ ------ ]]
   C-u        scroll <n> lines upward                          [[ ------ ]]
   C-v        blockwise select                                 [[ ------ ]]
   C-w        window command prefix                            [[ useful ]]
   C-x        subtract <n> from number at/after cursor         [[ ------ ]]
   C-y        scroll <n> lines downward                        [[ ------ ]]
   C-z        suspend program and go to shell                  [[ ------ ]]
   <esc>                                                       [[ ------ ]]
   <cr>                                                        [[ ------ ]]
   <bs>                                                        [[ ------ ]]
   !          filter <motion> text thru something              [[ ------ ]]
   "          use a register for next action                   [[ USEFUL ]]
   '          go to a specific mark                            [[ USEFUL ]]
   #          search backwards for what's under cursor         [[ USEFUL ]]
   *          search forewards for what's under cursor         [[ USEFUL ]]
   $          end of line                                      [[ USEFUL ]]
   %          find matching whatever                           [[ USEFUL ]]
   &          repeat last s/                                   [[ USEFUL ]]
   (          scroll <n> sentences upward                      [[ ------ ]]
   )          scroll <n> sentences downward                    [[ ------ ]]
   {          scroll <n> paragraph upward                      [[ ------ ]]
   }          scroll <n> paragraph downward                    [[ ------ ]]
   +          line down                                        [[ ------ ]]
   -          line up                                          [[ ------ ]]
   .          repeat last change at current position           [[ USEFUL ]]
   ,                                                           [[ ------ ]]
   /          search                                           [[ USEFUL ]]
   ?          search backwards                                 [[ USEFUL ]]
   :          enter command mode                               [[ USEFUL ]]
   ;                                                           [[ ------ ]]
   <          shift lines left                                 [[ ------ ]]
   <<         shift lines left                                 [[ ------ ]]
   >          shift lines right                                [[ ------ ]]
   >>         shift lines right                                [[ ------ ]]
   =          put lines through indent                         [[ ------ ]]
   ==         put lines through indent                         [[ ------ ]]
   @          execute a registers contents                     [[ USEFUL ]]
   _          cursor to start of next line                     [[ ------ ]]
   ^          beginning of line                                [[ USEFUL ]]
   |          go to column <n>                                 [[ ------ ]]
   ~          switch case                                      [[ useful ]]
   A          append after text                                [[ useful ]]
   B          backwards <n> WORDS                              [[ ------ ]]
   C          cursor till end-of-line                          [[ ------ ]]
   D          delete till end-of-line                          [[ useful ]]
   E          forwards <n> WORDS                               [[ ------ ]]
   F          find character backwards                         [[ maybe  ]]
   G          cursor to line <n>                               [[ ------ ]]
   H          cursor to line <n> from top of screen            [[ ------ ]]
   I          insert before first char                         [[ useful ]]
   J          join lines                                       [[ useful ]]
   K          lookup keyword under cursor                      [[ maybe  ]]
   L          cursor to line <n> from bottom of screen         [[ ------ ]]
   M          cursor to middle line of screen                  [[ ------ ]]
   N          repeat the latest search in opposite direction   [[ USEFUL ]]
   O          insert a new line above current                  [[ useful ]]
   P          paste text                                       [[ USEFUL ]]
   Q          switch to EX mode                                [[ ------ ]]
   R          replace mode                                     [[ useful ]]
   S          delete lines and start insert                    [[ ------ ]]
   T          cursor till after <char>                         [[ maybe  ]]
   U          undo all changes on current line                 [[ maybe  ]]
   V          start linewise selection                         [[ maybe  ]]
   W          cursor <n> WORDS forward                         [[ ------ ]]
   X          delete chars before cursor                       [[ maybe  ]]
   Y          yank selected lines into buffer                  [[ USEFUL ]]
   Z          - - - - - - -                                    [[ ------ ]]
   a          append after cursor                              [[ useful ]]
   b          cursor back <n> words                            [[ ------ ]]
   c          delete and start intsert                         [[ ------ ]]
   d          delete                                           [[ USEFUL ]]
   e          cursor forward <n> words                         [[ ------ ]]
   f          cursor forward to <char> to the right            [[ maybe  ]]
   g          EXTENDED COMMANDS                                [[ USEFUL ]]
   h          cursor left                                      [[ USEFUL ]]
   i          insert before the cursor                         [[ USEFUL ]]
   j          cursor down                                      [[ USEFUL ]]
   k          cursor up                                        [[ USEFUL ]]
   l          cursor right                                     [[ USEFUL ]]
   m          set a mark                                       [[ USEFUL ]]
   n          next search                                      [[ USEFUL ]]
   o          insert a line after                              [[ useful ]]
   p          paste text after cursor                          [[ useful ]]
   q          record macro                                     [[ USEFUL ]]
   r          replace character                                [[ useful ]]
   s          delete and start insert                          [[ ------ ]]
   t          cursor before <char>                             [[ maybe  ]]
   u          undo                                             [[ USEFUL ]]
   v          characterwise visual select                      [[ useful ]]
   w          cursor <n> words forward                         [[ ------ ]]
   x          delete under cursor                              [[ USEFUL ]]
   y          yank selected text                               [[ USEFUL ]]
   z          EXTENDED                                         [[ USEFUL ]]

.B visual mode
   C-@                                                         [[ ------ ]]
   C-a                                                         [[ ------ ]]
   C-b                                                         [[ ------ ]]
   C-c        stop visual mode (dup of <esc>)                  [[ ------ ]]
   C-d                                                         [[ ------ ]]
   C-e                                                         [[ ------ ]]
   C-f                                                         [[ ------ ]]
   C-g        toggle visual/select modes                       [[ ------ ]]
   C-h        dup of <bs>                                      [[ ------ ]]
   C-i                                                         [[ ------ ]]
   C-j                                                         [[ ------ ]]
   C-k                                                         [[ ------ ]]
   C-l                                                         [[ ------ ]]
   C-m                                                         [[ ------ ]]
   C-n                                                         [[ ------ ]]
   C-o        switch to select mode for one command            [[ ------ ]]
   C-p                                                         [[ ------ ]]
   C-q                                                         [[ ------ ]]
   C-r                                                         [[ ------ ]]
   C-s                                                         [[ ------ ]]
   C-t                                                         [[ ------ ]]
   C-u                                                         [[ ------ ]]
   C-v        switch to blockwise                              [[ ------ ]]
   C-w                                                         [[ ------ ]]
   C-x                                                         [[ ------ ]]
   C-y                                                         [[ ------ ]]
   C-z                                                         [[ ------ ]]
   <esc>      switch to normal mode                            [[ ------ ]]
   <cr>                                                        [[ ------ ]]
   <bs>                                                        [[ ------ ]]
   !          filter highlighted lines                         [[ useful ]]
   "                                                           [[ ------ ]]
   '                                                           [[ ------ ]]
   #                                                           [[ ------ ]]
   *                                                           [[ ------ ]]
   $                                                           [[ ------ ]]
   %                                                           [[ ------ ]]
   &                                                           [[ ------ ]]
   (                                                           [[ ------ ]]
   )                                                           [[ ------ ]]
   {                                                           [[ ------ ]]
   }                                                           [[ ------ ]]
   +                                                           [[ ------ ]]
   -                                                           [[ ------ ]]
   .                                                           [[ ------ ]]
   ,                                                           [[ ------ ]]
   /                                                           [[ ------ ]]
   ?                                                           [[ ------ ]]
   :          command mode with highlighted lines              [[ USEFUL ]]
   ;                                                           [[ ------ ]]
   <          shift highlighted lines                          [[ ------ ]]
   <<                                                          [[ ------ ]]
   >          shift highlighted lines                          [[ ------ ]]
   >>                                                          [[ ------ ]]
   =          filter highlighted lines                         [[ ------ ]]
   ==                                                          [[ ------ ]]
   @                                                           [[ ------ ]]
   |                                                           [[ ------ ]]
   ~          swap case                                        [[ ------ ]]
   A          append same text to all lines at end             [[ ------ ]]
   B                                                           [[ ------ ]]
   C          delete highlighted lines and insert              [[ ------ ]]
   D          delete highlighted lines                         [[ ------ ]]
   E                                                           [[ ------ ]]
   F                                                           [[ ------ ]]
   G                                                           [[ ------ ]]
   H                                                           [[ ------ ]]
   I          insert same text in all lines                    [[ ------ ]]
   J          join highlighted lines                           [[ ------ ]]
   K          lookup keyword                                   [[ ------ ]]
   L                                                           [[ ------ ]]
   M                                                           [[ ------ ]]
   N                                                           [[ ------ ]]
   O          move to other horizontal corner                  [[ ------ ]]
   P                                                           [[ ------ ]]
   Q                                                           [[ ------ ]]
   R          delete highlighted lines and insert              [[ ------ ]]
   S          delete highlighted lines and insert              [[ ------ ]]
   T                                                           [[ ------ ]]
   U          uppercase highlighted area                       [[ ------ ]]
   V          make visual mode linewise                        [[ ------ ]]
   W                                                           [[ ------ ]]
   X          delete highlighted lines                         [[ ------ ]]
   Y          yank highlighted lines                           [[ ------ ]]
   Z                                                           [[ ------ ]]
   a          EXTEND HIGHLIGHTED AREA (special)                [[ ------ ]]
   b                                                           [[ ------ ]]
   c          delete highlighted area and go to insert         [[ ------ ]]
   d          delete highlighted area                          [[ ------ ]]
   e                                                           [[ ------ ]]
   f                                                           [[ ------ ]]
   g                                                           [[ ------ ]]
   h                                                           [[ ------ ]]
   i          EXTEND HIGHLIGHTED AREA (special)                [[ ------ ]]
   j                                                           [[ ------ ]]
   k                                                           [[ ------ ]]
   l                                                           [[ ------ ]]
   m                                                           [[ ------ ]]
   n                                                           [[ ------ ]]
   o          move cursor to the other corner of area          [[ ------ ]]
   p                                                           [[ ------ ]]
   q                                                           [[ ------ ]]
   r          delete highlighted area and start insert         [[ ------ ]]
   s          delete highlighted area and start insert         [[ ------ ]]
   t                                                           [[ ------ ]]
   u          make lower case                                  [[ ------ ]]
   v          switch to characterwise visual mode              [[ ------ ]]
   w                                                           [[ ------ ]]
   x          delete highlighted area and start insert         [[ ------ ]]
   y          yank highlighted area                            [[ ------ ]]
   z                                                           [[ ------ ]]

.B 'g' commands
   gC-@                                                        [[ ------ ]]
   gC-a                                                        [[ ------ ]]
   gC-b                                                        [[ ------ ]]
   gC-c                                                        [[ ------ ]]
   gC-d                                                        [[ ------ ]]
   gC-e                                                        [[ ------ ]]
   gC-f                                                        [[ ------ ]]
   gC-g       information about current cursor position        [[ useful ]]
   gC-h       start select block mode                          [[ ------ ]]
   gC-i                                                        [[ ------ ]]
   gC-j                                                        [[ ------ ]]
   gC-k                                                        [[ ------ ]]
   gC-l                                                        [[ ------ ]]
   gC-m                                                        [[ ------ ]]
   gC-n                                                        [[ ------ ]]
   gC-o                                                        [[ ------ ]]
   gC-p                                                        [[ ------ ]]
   gC-q                                                        [[ ------ ]]
   gC-r                                                        [[ ------ ]]
   gC-s                                                        [[ ------ ]]
   gC-t                                                        [[ ------ ]]
   gC-u                                                        [[ ------ ]]
   gC-v                                                        [[ ------ ]]
   gC-w                                                        [[ ------ ]]
   gC-x                                                        [[ ------ ]]
   gC-y                                                        [[ ------ ]]
   gC-z                                                        [[ ------ ]]
   gA                                                          [[ ------ ]]
   gB                                                          [[ ------ ]]
   gC                                                          [[ ------ ]]
   gD         do to definition of word under cursor            [[ useful ]]
   gE         like E                                           [[ ------ ]]
   gF                                                          [[ ------ ]]
   gG                                                          [[ ------ ]]
   gH         start select line mode                           [[ ------ ]]
   gI         like I                                           [[ ------ ]]
   gJ         like join lines                                  [[ ------ ]]
   gK                                                          [[ ------ ]]
   gL                                                          [[ ------ ]]
   gM                                                          [[ ------ ]]
   gN         like N                                           [[ ------ ]]
   gO                                                          [[ ------ ]]
   gP                                                          [[ ------ ]]
   gQ                                                          [[ ------ ]]
   gR                                                          [[ ------ ]]
   gS                                                          [[ ------ ]]
   gT                                                          [[ ------ ]]
   gU                                                          [[ ------ ]]
   gV                                                          [[ ------ ]]
   gW                                                          [[ ------ ]]
   gX                                                          [[ ------ ]]
   gY                                                          [[ ------ ]]
   gZ                                                          [[ ------ ]]
   g!                                                          [[ ------ ]]
   g"                                                          [[ ------ ]]
   g'         like '                                           [[ ------ ]]
   g#         like #                                           [[ ------ ]]
   g*         like *                                           [[ ------ ]]
   g$         like $                                           [[ ------ ]]
   g%                                                          [[ ------ ]]
   g&         do :s on all lines                               [[ ------ ]]
   g(                                                          [[ ------ ]]
   g)                                                          [[ ------ ]]
   g{                                                          [[ ------ ]]
   g}                                                          [[ ------ ]]
   g+         go to newer state                                [[ ------ ]]
   g-         go to older state                                [[ ------ ]]
   g.                                                          [[ ------ ]]
   g,         go to newer position in change list              [[ ------ ]]
   g/                                                          [[ ------ ]]
   g?         rot13 encoding                                   [[ ------ ]]
   g:                                                          [[ ------ ]]
   g;         go to older position in chang list               [[ ------ ]]
   g<         display previous command output                  [[ ------ ]]
   g<<                                                         [[ ------ ]]
   g>                                                          [[ ------ ]]
   g>>                                                         [[ ------ ]]
   g=                                                          [[ ------ ]]
   g==                                                         [[ ------ ]]
   g@                                                          [[ ------ ]]
   g|                                                          [[ ------ ]]
   g~                                                          [[ ------ ]]
   ga                                                          [[ ------ ]]
   gb                                                          [[ ------ ]]
   gc                                                          [[ ------ ]]
   gd                                                          [[ ------ ]]
   ge         end of previous work in wrap mode                [[ ------ ]]
   gf                                                          [[ ------ ]]
   gg                                                          [[ ------ ]]
   gh         start select mode                                [[ ------ ]]
   gi                                                          [[ ------ ]]
   gj                                                          [[ ------ ]]
   gk                                                          [[ ------ ]]
   gl                                                          [[ ------ ]]
   gm                                                          [[ ------ ]]
   gn                                                          [[ ------ ]]
   go                                                          [[ ------ ]]
   gp                                                          [[ ------ ]]
   gq                                                          [[ ------ ]]
   gr                                                          [[ ------ ]]
   gs         go to sleep                                      [[ ------ ]]
   gt                                                          [[ ------ ]]
   gu                                                          [[ ------ ]]
   gv                                                          [[ ------ ]]
   gw                                                          [[ ------ ]]
   gx                                                          [[ ------ ]]
   gy                                                          [[ ------ ]]
   gz                                                          [[ ------ ]]
   g0                                                          [[ ------ ]]
   g1                                                          [[ ------ ]]
   g2                                                          [[ ------ ]]
   g3                                                          [[ ------ ]]
   g4                                                          [[ ------ ]]
   g5                                                          [[ ------ ]]
   g6                                                          [[ ------ ]]
   g7                                                          [[ ------ ]]
   g8         show hex value                                   [[ ------ ]]
   g9                                                          [[ ------ ]]


.B 'z' commands
   zC-@                                                        [[ ------ ]]
   zC-a                                                        [[ ------ ]]
   zC-b                                                        [[ ------ ]]
   zC-c                                                        [[ ------ ]]
   zC-d                                                        [[ ------ ]]
   zC-e                                                        [[ ------ ]]
   zC-f                                                        [[ ------ ]]
   zC-g                                                        [[ ------ ]]
   zC-h                                                        [[ ------ ]]
   zC-i                                                        [[ ------ ]]
   zC-j                                                        [[ ------ ]]
   zC-k                                                        [[ ------ ]]
   zC-l                                                        [[ ------ ]]
   zC-m                                                        [[ ------ ]]
   zC-n                                                        [[ ------ ]]
   zC-o                                                        [[ ------ ]]
   zC-p                                                        [[ ------ ]]
   zC-q                                                        [[ ------ ]]
   zC-r                                                        [[ ------ ]]
   zC-s                                                        [[ ------ ]]
   zC-t                                                        [[ ------ ]]
   zC-u                                                        [[ ------ ]]
   zC-v                                                        [[ ------ ]]
   zC-w                                                        [[ ------ ]]
   zC-x                                                        [[ ------ ]]
   zC-y                                                        [[ ------ ]]
   zC-z                                                        [[ ------ ]]
   zA         open a closed fold                               [[ ------ ]]
   zB                                                          [[ ------ ]]
   zC         close an open fold                               [[ ------ ]]
   zD         delete fold                                      [[ ------ ]]
   zE         eliminate all folds                              [[ ------ ]]
   zF         create a fold                                    [[ ------ ]]
   zG         mark as correctly spelled                        [[ ------ ]]
   zH         scroll half screen to right                      [[ ------ ]]
   zI         scroll half screen to left                       [[ ------ ]]
   zJ                                                          [[ ------ ]]
   zK                                                          [[ ------ ]]
   zL                                                          [[ ------ ]]
   zM         open all folds                                   [[ ------ ]]
   zN         enable folds                                     [[ ------ ]]
   zO         open folds                                       [[ ------ ]]
   zP                                                          [[ ------ ]]
   zQ                                                          [[ ------ ]]
   zR         enable folds                                     [[ ------ ]]
   zS                                                          [[ ------ ]]
   zT                                                          [[ ------ ]]
   zU                                                          [[ ------ ]]
   zV                                                          [[ ------ ]]
   zW         mark word as badly spelled                       [[ ------ ]]
   zX                                                          [[ ------ ]]
   zY                                                          [[ ------ ]]
   zZ                                                          [[ ------ ]]
   z!                                                          [[ ------ ]]
   z"                                                          [[ ------ ]]
   z'                                                          [[ ------ ]]
   z#                                                          [[ ------ ]]
   z*                                                          [[ ------ ]]
   z$                                                          [[ ------ ]]
   z%                                                          [[ ------ ]]
   z&                                                          [[ ------ ]]
   z(                                                          [[ ------ ]]
   z)                                                          [[ ------ ]]
   z{                                                          [[ ------ ]]
   z}                                                          [[ ------ ]]
   z+         scroll current line to top                       [[ ------ ]]
   z-         scroll current line to bottom                    [[ ------ ]]
   z.         scroll current line to center                    [[ ------ ]]
   z,                                                          [[ ------ ]]
   z/                                                          [[ ------ ]]
   z?                                                          [[ ------ ]]
   z:                                                          [[ ------ ]]
   z;                                                          [[ ------ ]]
   z<                                                          [[ ------ ]]
   z<<                                                         [[ ------ ]]
   z>                                                          [[ ------ ]]
   z>>                                                         [[ ------ ]]
   z=                                                          [[ ------ ]]
   z==                                                         [[ ------ ]]
   z@                                                          [[ ------ ]]
   z|                                                          [[ ------ ]]
   z~                                                          [[ ------ ]]
   za         open a fold                                      [[ ------ ]]
   zb         scroll current line to bottom                    [[ ------ ]]
   zc         close a fold                                     [[ ------ ]]
   zd         delete a fold                                    [[ ------ ]]
   ze         scroll current column to right end of screen     [[ ------ ]]
   zf         create a fold                                    [[ ------ ]]
   zg         mark word as correctly spelled                   [[ ------ ]]
   zh         scroll character to right                        [[ ------ ]]
   zi         toggle folds                                     [[ ------ ]]
   zj         start of next fold                               [[ ------ ]]
   zk         end of previous fold                             [[ ------ ]]
   zl         scroll character to left                         [[ ------ ]]
   zm         less fold levels shown                           [[ ------ ]]
   zn         reset folds                                      [[ ------ ]]
   zo         open fold                                        [[ ------ ]]
   zp                                                          [[ ------ ]]
   zq                                                          [[ ------ ]]
   zr         add one to foldlevel                             [[ ------ ]]
   zs         scroll current col to left side                  [[ ------ ]]
   zt         scroll current row to top                        [[ ------ ]]
   zu                                                          [[ ------ ]]
   zv         open folds                                       [[ ------ ]]
   zw         mark as badly spelled                            [[ ------ ]]
   zx         reapply fold level                               [[ ------ ]]
   zy                                                          [[ ------ ]]
   zz         redraw line to center                            [[ ------ ]]
   z0                                                          [[ ------ ]]
   z1                                                          [[ ------ ]]
   z2                                                          [[ ------ ]]
   z3                                                          [[ ------ ]]
   z4                                                          [[ ------ ]]
   z5                                                          [[ ------ ]]
   z6                                                          [[ ------ ]]
   z7                                                          [[ ------ ]]
   z8                                                          [[ ------ ]]
   z9                                                          [[ ------ ]]


.SH SEE ALSO
this documentation is layered to provide easier navigation.
   yVIKEYS (3), interfacing applications with yVIKEYS
   yVIKEYS (5), data file format and structure
   yVIKEYS (6), interactive system usage and navigation
   yVIKEYS (7), decision rationale, objectives, and overview
   yVIKEYS (9), user interface behavior guarantees (automation)

.SH AUTHOR
jelloshrike at gmail dot com

.SH COLOPHON
this page is part of a documentation package meant to make use of the
heatherly tools easier and faster.
